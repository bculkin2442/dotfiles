*java.time.LocalDate* *LocalDate* A date without a time-zone in the ISO-8601 cal

public final class LocalDate
  extends    |java.lang.Object|
  implements |java.time.temporal.Temporal|
             |java.time.temporal.TemporalAdjuster|
             |java.time.chrono.ChronoLocalDate|
             |java.io.Serializable|

|java.time.LocalDate_Description|
|java.time.LocalDate_Fields|
|java.time.LocalDate_Constructors|
|java.time.LocalDate_Methods|

================================================================================

*java.time.LocalDate_Fields*
|java.time.LocalDate_java.time.LocalDate.MAX|
|java.time.LocalDate_java.time.LocalDate.MIN|

*java.time.LocalDate_Methods*
|java.time.LocalDate.adjustInto(Temporal)|Adjusts the specified temporal object
|java.time.LocalDate.atStartOfDay()|Combines this date with the time of midnigh
|java.time.LocalDate.atStartOfDay(ZoneId)|Returns a zoned date-time from this d
|java.time.LocalDate.atTime(int,int)|Combines this date with a time to create a
|java.time.LocalDate.atTime(int,int,int)|Combines this date with a time to crea
|java.time.LocalDate.atTime(int,int,int,int)|Combines this date with a time to 
|java.time.LocalDate.atTime(LocalTime)|Combines this date with a time to create
|java.time.LocalDate.atTime(OffsetTime)|Combines this date with an offset time 
|java.time.LocalDate.compareTo(ChronoLocalDate)|Compares this date to another d
|java.time.LocalDate.equals(Object)|Checks if this date is equal to another dat
|java.time.LocalDate.format(DateTimeFormatter)|Formats this date using the spec
|java.time.LocalDate.from(TemporalAccessor)|Obtains an instance ofLocalDatefrom
|java.time.LocalDate.get(TemporalField)|Gets the value of the specified field f
|java.time.LocalDate.getChronology()|Gets the chronology of this date, which is
|java.time.LocalDate.getDayOfMonth()|Gets the day-of-month field.
|java.time.LocalDate.getDayOfWeek()|Gets the day-of-week field, which is an enu
|java.time.LocalDate.getDayOfYear()|Gets the day-of-year field.
|java.time.LocalDate.getEra()|Gets the era applicable at this date.
|java.time.LocalDate.getLong(TemporalField)|Gets the value of the specified fie
|java.time.LocalDate.getMonth()|Gets the month-of-year field using theMonthenum
|java.time.LocalDate.getMonthValue()|Gets the month-of-year field from 1 to 12.
|java.time.LocalDate.getYear()|Gets the year field.
|java.time.LocalDate.hashCode()|A hash code for this date.
|java.time.LocalDate.isAfter(ChronoLocalDate)|Checks if this date is after the 
|java.time.LocalDate.isBefore(ChronoLocalDate)|Checks if this date is before th
|java.time.LocalDate.isEqual(ChronoLocalDate)|Checks if this date is equal to t
|java.time.LocalDate.isLeapYear()|Checks if the year is a leap year, according 
|java.time.LocalDate.isSupported(TemporalField)|Checks if the specified field i
|java.time.LocalDate.isSupported(TemporalUnit)|Checks if the specified unit is 
|java.time.LocalDate.lengthOfMonth()|Returns the length of the month represente
|java.time.LocalDate.lengthOfYear()|Returns the length of the year represented 
|java.time.LocalDate.minus(long,TemporalUnit)|Returns a copy of this date with 
|java.time.LocalDate.minus(TemporalAmount)|Returns a copy of this date with the
|java.time.LocalDate.minusDays(long)|Returns a copy of thisLocalDatewith the sp
|java.time.LocalDate.minusMonths(long)|Returns a copy of thisLocalDatewith the 
|java.time.LocalDate.minusWeeks(long)|Returns a copy of thisLocalDatewith the s
|java.time.LocalDate.minusYears(long)|Returns a copy of thisLocalDatewith the s
|java.time.LocalDate.now()|Obtains the current date from the system clock in th
|java.time.LocalDate.now(Clock)|Obtains the current date from the specified clo
|java.time.LocalDate.now(ZoneId)|Obtains the current date from the system clock
|java.time.LocalDate.of(int,int,int)|Obtains an instance ofLocalDatefrom a year
|java.time.LocalDate.of(int,Month,int)|Obtains an instance ofLocalDatefrom a ye
|java.time.LocalDate.ofEpochDay(long)|Obtains an instance ofLocalDatefrom the e
|java.time.LocalDate.ofYearDay(int,int)|Obtains an instance ofLocalDatefrom a y
|java.time.LocalDate.parse(CharSequence)|Obtains an instance ofLocalDatefrom a 
|java.time.LocalDate.parse(CharSequence,DateTimeFormatter)|Obtains an instance 
|java.time.LocalDate.plus(long,TemporalUnit)|Returns a copy of this date with t
|java.time.LocalDate.plus(TemporalAmount)|Returns a copy of this date with the 
|java.time.LocalDate.plusDays(long)|Returns a copy of thisLocalDatewith the spe
|java.time.LocalDate.plusMonths(long)|Returns a copy of thisLocalDatewith the s
|java.time.LocalDate.plusWeeks(long)|Returns a copy of thisLocalDatewith the sp
|java.time.LocalDate.plusYears(long)|Returns a copy of thisLocalDatewith the sp
|java.time.LocalDate.query(TemporalQuery<R>)|Queries this date using the specif
|java.time.LocalDate.range(TemporalField)|Gets the range of valid values for th
|java.time.LocalDate.toEpochDay()|
|java.time.LocalDate.toString()|Outputs this date as aString, such as2007-12-03
|java.time.LocalDate.until(ChronoLocalDate)|Calculates the period between this 
|java.time.LocalDate.until(Temporal,TemporalUnit)|Calculates the amount of time
|java.time.LocalDate.with(TemporalAdjuster)|Returns an adjusted copy of this da
|java.time.LocalDate.with(TemporalField,long)|Returns a copy of this date with 
|java.time.LocalDate.withDayOfMonth(int)|Returns a copy of this date with the d
|java.time.LocalDate.withDayOfYear(int)|Returns a copy of this date with the da
|java.time.LocalDate.withMonth(int)|Returns a copy of this date with the month-
|java.time.LocalDate.withYear(int)|Returns a copy of this date with the year al

*java.time.LocalDate_Description*

A date without a time-zone in the ISO-8601 calendar system, such as2007-12-03. 
LocalDateis an immutable date-time object that represents a date, often viewed 
as year-month-day. Other date fields, such as day-of-year, day-of-week and 
week-of-year, can also be accessed. For example, the value "2nd October 2007" 
can be stored in aLocalDate. 

This class does not store or represent a time or time-zone. Instead, it is a 
description of the date, as used for birthdays. It cannot represent an instant 
on the time-line without additional information such as an offset or time-zone. 

The ISO-8601 calendar system is the modern civil calendar system used today in 
most of the world. It is equivalent to the proleptic Gregorian calendar system, 
in which today's rules for leap years are applied for all time. For most 
applications written today, the ISO-8601 rules are entirely suitable. However, 
any application that makes use of historical dates, and requires them to be 
accurate will find the ISO-8601 approach unsuitable. 

This is a <a href="/java/lang/doc-files/ValueBased.html">value-based class; use 
of identity-sensitive operations (including reference equality (==), identity 
hash code, or synchronization) on instances ofLocalDatemay have unpredictable 
results and should be avoided. Theequalsmethod should be used for comparisons. 



*java.time.LocalDate_java.time.LocalDate.MAX*

The maximum supportedLocalDate, '+999999999-12-31'. This could be used by an 
application as a "far future" date. 


*java.time.LocalDate_java.time.LocalDate.MIN*

The minimum supportedLocalDate, '-999999999-01-01'. This could be used by an 
application as a "far past" date. 



*java.time.LocalDate.adjustInto(Temporal)*

public |java.time.temporal.Temporal| adjustInto(java.time.temporal.Temporal temporal)

Adjusts the specified temporal object to have the same date as this object. 

This returns a temporal object of the same observable type as the input with 
the date changed to be the same as this. 

The adjustment is equivalent to using (|java.time.temporal.Temporal|) passing 
(|java.time.temporal.ChronoField|) as the field. 

In most cases, it is clearer to reverse the calling pattern by using 
(|java.time.temporal.Temporal|) : 

// these two lines are equivalent, but the second approach is recommended 
temporal = thisLocalDate.adjustInto(temporal); temporal = 
temporal.with(thisLocalDate); 

This instance is immutable and unaffected by this method call. 


    temporal - the target object to be adjusted, not null 

    Returns: the adjusted object, not null 

*java.time.LocalDate.atStartOfDay()*

public |java.time.LocalDateTime| atStartOfDay()

Combines this date with the time of midnight to create aLocalDateTimeat the 
start of this date. 

This returns aLocalDateTimeformed from this date at the time of midnight, 
00:00, at the start of this date. 



    Returns: the local date-time of midnight at the start of this date, not null 

*java.time.LocalDate.atStartOfDay(ZoneId)*

public |java.time.ZonedDateTime| atStartOfDay(java.time.ZoneId zone)

Returns a zoned date-time from this date at the earliest valid time according 
to the rules in the time-zone. 

Time-zone rules, such as daylight savings, mean that not every local date-time 
is valid for the specified zone, thus the local date-time may not be midnight. 

In most cases, there is only one valid offset for a local date-time. In the 
case of an overlap, there are two valid offsets, and the earlier one is used, 
corresponding to the first occurrence of midnight on the date. In the case of a 
gap, the zoned date-time will represent the instant just after the gap. 

If the zone ID is a (|java.time.ZoneOffset|) , then the result always has a 
time of midnight. 

To convert to a specific time in a given time-zone call (|java.time.LocalDate|) 
followed by (|java.time.LocalDateTime|) . 


    zone - the zone ID to use, not null 

    Returns: the zoned date-time formed from this date and the earliest valid time for the 
             zone, not null 

*java.time.LocalDate.atTime(int,int)*

public |java.time.LocalDateTime| atTime(
  int hour,
  int minute)

Combines this date with a time to create aLocalDateTime. 

This returns aLocalDateTimeformed from this date at the specified hour and 
minute. The seconds and nanosecond fields will be set to zero. The individual 
time fields must be within their valid range. All possible combinations of date 
and time are valid. 


    hour - the hour-of-day to use, from 0 to 23 
    minute - the minute-of-hour to use, from 0 to 59 

    Returns: the local date-time formed from this date and the specified time, not null 

*java.time.LocalDate.atTime(int,int,int)*

public |java.time.LocalDateTime| atTime(
  int hour,
  int minute,
  int second)

Combines this date with a time to create aLocalDateTime. 

This returns aLocalDateTimeformed from this date at the specified hour, minute 
and second. The nanosecond field will be set to zero. The individual time 
fields must be within their valid range. All possible combinations of date and 
time are valid. 


    hour - the hour-of-day to use, from 0 to 23 
    minute - the minute-of-hour to use, from 0 to 59 
    second - the second-of-minute to represent, from 0 to 59 

    Returns: the local date-time formed from this date and the specified time, not null 

*java.time.LocalDate.atTime(int,int,int,int)*

public |java.time.LocalDateTime| atTime(
  int hour,
  int minute,
  int second,
  int nanoOfSecond)

Combines this date with a time to create aLocalDateTime. 

This returns aLocalDateTimeformed from this date at the specified hour, minute, 
second and nanosecond. The individual time fields must be within their valid 
range. All possible combinations of date and time are valid. 


    hour - the hour-of-day to use, from 0 to 23 
    minute - the minute-of-hour to use, from 0 to 59 
    second - the second-of-minute to represent, from 0 to 59 
    nanoOfSecond - the nano-of-second to represent, from 0 to 999,999,999 

    Returns: the local date-time formed from this date and the specified time, not null 

*java.time.LocalDate.atTime(LocalTime)*

public |java.time.LocalDateTime| atTime(java.time.LocalTime time)

Combines this date with a time to create aLocalDateTime. 

This returns aLocalDateTimeformed from this date at the specified time. All 
possible combinations of date and time are valid. 


    time - the time to combine with, not null 

    Returns: the local date-time formed from this date and the specified time, not null 

*java.time.LocalDate.atTime(OffsetTime)*

public |java.time.OffsetDateTime| atTime(java.time.OffsetTime time)

Combines this date with an offset time to create anOffsetDateTime. 

This returns anOffsetDateTimeformed from this date at the specified time. All 
possible combinations of date and time are valid. 


    time - the time to combine with, not null 

    Returns: the offset date-time formed from this date and the specified time, not null 

*java.time.LocalDate.compareTo(ChronoLocalDate)*

public int compareTo(java.time.chrono.ChronoLocalDate other)

Compares this date to another date. 

The comparison is primarily based on the date, from earliest to latest. It is 
"consistent with equals", as defined by (|java.lang.Comparable|) . 

If all the dates being compared are instances ofLocalDate, then the comparison 
will be entirely based on the date. If some dates being compared are in 
different chronologies, then the chronology is also considered, see 
(|java.time.chrono.ChronoLocalDate|) . 


    other - the other date to compare to, not null 

    Returns: the comparator value, negative if less, positive if greater 

*java.time.LocalDate.equals(Object)*

public boolean equals(java.lang.Object obj)

Checks if this date is equal to another date. 

Compares thisLocalDatewith another ensuring that the date is the same. 

Only objects of typeLocalDateare compared, other types return false. To compare 
the dates of twoTemporalAccessorinstances, including dates in two different 
chronologies, use (|java.time.temporal.ChronoField|) as a comparator. 


    obj - the object to check, null returns false 

    Returns: true if this is equal to the other date 

*java.time.LocalDate.format(DateTimeFormatter)*

public |java.lang.String| format(java.time.format.DateTimeFormatter formatter)

Formats this date using the specified formatter. 

This date will be passed to the formatter to produce a string. 


    formatter - the formatter to use, not null 

    Returns: the formatted date string, not null 

*java.time.LocalDate.from(TemporalAccessor)*

public static |java.time.LocalDate| from(java.time.temporal.TemporalAccessor temporal)

Obtains an instance ofLocalDatefrom a temporal object. 

This obtains a local date based on the specified temporal. 
ATemporalAccessorrepresents an arbitrary set of date and time information, 
which this factory converts to an instance ofLocalDate. 

The conversion uses the (|java.time.temporal.TemporalQueries|) query, which 
relies on extracting the EPOCH_DAY(|java.time.temporal.ChronoField|) field. 

This method matches the signature of the functional interface 
(|java.time.temporal.TemporalQuery|) allowing it to be used as a query via 
method reference,LocalDate::from. 


    temporal - the temporal object to convert, not null 

    Returns: the local date, not null 

*java.time.LocalDate.get(TemporalField)*

public int get(java.time.temporal.TemporalField field)

Gets the value of the specified field from this date as anint. 

This queries this date for the value for the specified field. The returned 
value will always be within the valid range of values for the field. If it is 
not possible to return the value, because the field is not supported or for 
some other reason, an exception is thrown. 

If the field is a (|java.time.temporal.ChronoField|) then the query is 
implemented here. The supported fields(|java.time.LocalDate|) will return valid 
values based on this date, exceptEPOCH_DAYandPROLEPTIC_MONTHwhich are too large 
to fit in anintand throw aDateTimeException. All otherChronoFieldinstances will 
throw anUnsupportedTemporalTypeException. 

If the field is not aChronoField, then the result of this method is obtained by 
invokingTemporalField.getFrom(TemporalAccessor)passingthisas the argument. 
Whether the value can be obtained, and what the value represents, is determined 
by the field. 


    field - the field to get, not null 

    Returns: the value for the field 

*java.time.LocalDate.getChronology()*

public |java.time.chrono.IsoChronology| getChronology()

Gets the chronology of this date, which is the ISO calendar system. 

TheChronologyrepresents the calendar system in use. The ISO-8601 calendar 
system is the modern civil calendar system used today in most of the world. It 
is equivalent to the proleptic Gregorian calendar system, in which today's 
rules for leap years are applied for all time. 



    Returns: the ISO chronology, not null 

*java.time.LocalDate.getDayOfMonth()*

public int getDayOfMonth()

Gets the day-of-month field. 

This method returns the primitiveintvalue for the day-of-month. 



    Returns: the day-of-month, from 1 to 31 

*java.time.LocalDate.getDayOfWeek()*

public |java.time.DayOfWeek| getDayOfWeek()

Gets the day-of-week field, which is an enumDayOfWeek. 

This method returns the enum (|java.time.DayOfWeek|) for the day-of-week. This 
avoids confusion as to whatintvalues mean. If you need access to the 
primitiveintvalue then the enum provides the int value(|java.time.DayOfWeek|) . 

Additional information can be obtained from theDayOfWeek. This includes textual 
names of the values. 



    Returns: the day-of-week, not null 

*java.time.LocalDate.getDayOfYear()*

public int getDayOfYear()

Gets the day-of-year field. 

This method returns the primitiveintvalue for the day-of-year. 



    Returns: the day-of-year, from 1 to 365, or 366 in a leap year 

*java.time.LocalDate.getEra()*

public |java.time.chrono.Era| getEra()

Gets the era applicable at this date. 

The official ISO-8601 standard does not define eras, howeverIsoChronologydoes. 
It defines two eras, 'CE' from year one onwards and 'BCE' from year zero 
backwards. Since dates before the Julian-Gregorian cutover are not in line with 
history, the cutover between 'BCE' and 'CE' is also not aligned with the 
commonly used eras, often referred to using 'BC' and 'AD'. 

Users of this class should typically ignore this method as it exists primarily 
to fulfill the (|java.time.chrono.ChronoLocalDate|) contract where it is 
necessary to support the Japanese calendar system. 

The returned era will be a singleton capable of being compared with the 
constants in (|java.time.chrono.IsoChronology|) using the==operator. 



    Returns: the {@code IsoChronology} era constant applicable at this date, not null 

*java.time.LocalDate.getLong(TemporalField)*

public long getLong(java.time.temporal.TemporalField field)

Gets the value of the specified field from this date as along. 

This queries this date for the value for the specified field. If it is not 
possible to return the value, because the field is not supported or for some 
other reason, an exception is thrown. 

If the field is a (|java.time.temporal.ChronoField|) then the query is 
implemented here. The supported fields(|java.time.LocalDate|) will return valid 
values based on this date. All otherChronoFieldinstances will throw 
anUnsupportedTemporalTypeException. 

If the field is not aChronoField, then the result of this method is obtained by 
invokingTemporalField.getFrom(TemporalAccessor)passingthisas the argument. 
Whether the value can be obtained, and what the value represents, is determined 
by the field. 


    field - the field to get, not null 

    Returns: the value for the field 

*java.time.LocalDate.getMonth()*

public |java.time.Month| getMonth()

Gets the month-of-year field using theMonthenum. 

This method returns the enum (|java.time.Month|) for the month. This avoids 
confusion as to whatintvalues mean. If you need access to the primitiveintvalue 
then the enum provides the int value(|java.time.Month|) . 



    Returns: the month-of-year, not null 

*java.time.LocalDate.getMonthValue()*

public int getMonthValue()

Gets the month-of-year field from 1 to 12. 

This method returns the month as anintfrom 1 to 12. Application code is 
frequently clearer if the enum (|java.time.Month|) is used by calling 
(|java.time.LocalDate|) . 



    Returns: the month-of-year, from 1 to 12 

*java.time.LocalDate.getYear()*

public int getYear()

Gets the year field. 

This method returns the primitiveintvalue for the year. 

The year returned by this method is proleptic as perget(YEAR). To obtain the 
year-of-era, useget(YEAR_OF_ERA). 



    Returns: the year, from MIN_YEAR to MAX_YEAR 

*java.time.LocalDate.hashCode()*

public int hashCode()

A hash code for this date. 



    Returns: a suitable hash code 

*java.time.LocalDate.isAfter(ChronoLocalDate)*

public boolean isAfter(java.time.chrono.ChronoLocalDate other)

Checks if this date is after the specified date. 

This checks to see if this date represents a point on the local time-line after 
the other date. 

LocalDate a = LocalDate.of(2012, 6, 30); LocalDate b = LocalDate.of(2012, 7, 
1); a.isAfter(b) == false a.isAfter(a) == false b.isAfter(a) == true 

This method only considers the position of the two dates on the local 
time-line. It does not take into account the chronology, or calendar system. 
This is different from the comparison in (|java.time.LocalDate|) , but is the 
same approach as (|java.time.chrono.ChronoLocalDate|) . 


    other - the other date to compare to, not null 

    Returns: true if this date is after the specified date 

*java.time.LocalDate.isBefore(ChronoLocalDate)*

public boolean isBefore(java.time.chrono.ChronoLocalDate other)

Checks if this date is before the specified date. 

This checks to see if this date represents a point on the local time-line 
before the other date. 

LocalDate a = LocalDate.of(2012, 6, 30); LocalDate b = LocalDate.of(2012, 7, 
1); a.isBefore(b) == true a.isBefore(a) == false b.isBefore(a) == false 

This method only considers the position of the two dates on the local 
time-line. It does not take into account the chronology, or calendar system. 
This is different from the comparison in (|java.time.LocalDate|) , but is the 
same approach as (|java.time.chrono.ChronoLocalDate|) . 


    other - the other date to compare to, not null 

    Returns: true if this date is before the specified date 

*java.time.LocalDate.isEqual(ChronoLocalDate)*

public boolean isEqual(java.time.chrono.ChronoLocalDate other)

Checks if this date is equal to the specified date. 

This checks to see if this date represents the same point on the local 
time-line as the other date. 

LocalDate a = LocalDate.of(2012, 6, 30); LocalDate b = LocalDate.of(2012, 7, 
1); a.isEqual(b) == false a.isEqual(a) == true b.isEqual(a) == false 

This method only considers the position of the two dates on the local 
time-line. It does not take into account the chronology, or calendar system. 
This is different from the comparison in (|java.time.LocalDate|) but is the 
same approach as (|java.time.chrono.ChronoLocalDate|) . 


    other - the other date to compare to, not null 

    Returns: true if this date is equal to the specified date 

*java.time.LocalDate.isLeapYear()*

public boolean isLeapYear()

Checks if the year is a leap year, according to the ISO proleptic calendar 
system rules. 

This method applies the current rules for leap years across the whole 
time-line. In general, a year is a leap year if it is divisible by four without 
remainder. However, years divisible by 100, are not leap years, with the 
exception of years divisible by 400 which are. 

For example, 1904 is a leap year it is divisible by 4. 1900 was not a leap year 
as it is divisible by 100, however 2000 was a leap year as it is divisible by 
400. 

The calculation is proleptic - applying the same rules into the far future and 
far past. This is historically inaccurate, but is correct for the ISO-8601 
standard. 



    Returns: true if the year is leap, false otherwise 

*java.time.LocalDate.isSupported(TemporalField)*

public boolean isSupported(java.time.temporal.TemporalField field)

Checks if the specified field is supported. 

This checks if this date can be queried for the specified field. If false, then 
calling the range(|java.time.LocalDate|) , get(|java.time.LocalDate|) and 
(|java.time.LocalDate|) methods will throw an exception. 

If the field is a (|java.time.temporal.ChronoField|) then the query is 
implemented here. The supported fields are: 

DAY_OF_WEEKALIGNED_DAY_OF_WEEK_IN_MONTHALIGNED_DAY_OF_WEEK_IN_YEARDAY_OF_MONTHDAY_OF_YEAREPOCH_DAYALIGNED_WEEK_OF_MONTHALIGNED_WEEK_OF_YEARMONTH_OF_YEARPROLEPTIC_MONTHYEAR_OF_ERAYEARERA
All otherChronoFieldinstances will return false. 

If the field is not aChronoField, then the result of this method is obtained by 
invokingTemporalField.isSupportedBy(TemporalAccessor)passingthisas the 
argument. Whether the field is supported is determined by the field. 


    field - the field to check, null returns false 

    Returns: true if the field is supported on this date, false if not 

*java.time.LocalDate.isSupported(TemporalUnit)*

public boolean isSupported(java.time.temporal.TemporalUnit unit)

Checks if the specified unit is supported. 

This checks if the specified unit can be added to, or subtracted from, this 
date-time. If false, then calling the (|java.time.LocalDate|) and 
minus(|java.time.LocalDate|) methods will throw an exception. 

If the unit is a (|java.time.temporal.ChronoUnit|) then the query is 
implemented here. The supported units are: 

DAYSWEEKSMONTHSYEARSDECADESCENTURIESMILLENNIAERAS All otherChronoUnitinstances 
will return false. 

If the unit is not aChronoUnit, then the result of this method is obtained by 
invokingTemporalUnit.isSupportedBy(Temporal)passingthisas the argument. Whether 
the unit is supported is determined by the unit. 


    unit - the unit to check, null returns false 

    Returns: true if the unit can be added/subtracted, false if not 

*java.time.LocalDate.lengthOfMonth()*

public int lengthOfMonth()

Returns the length of the month represented by this date. 

This returns the length of the month in days. For example, a date in January 
would return 31. 



    Returns: the length of the month in days 

*java.time.LocalDate.lengthOfYear()*

public int lengthOfYear()

Returns the length of the year represented by this date. 

This returns the length of the year in days, either 365 or 366. 



    Returns: 366 if the year is leap, 365 otherwise 

*java.time.LocalDate.minus(long,TemporalUnit)*

public |java.time.LocalDate| minus(
  long amountToSubtract,
  java.time.temporal.TemporalUnit unit)

Returns a copy of this date with the specified amount subtracted. 

This returns aLocalDate, based on this one, with the amount in terms of the 
unit subtracted. If it is not possible to subtract the amount, because the unit 
is not supported or for some other reason, an exception is thrown. 

This method is equivalent to (|java.time.LocalDate|) with the amount negated. 
See that method for a full description of how addition, and thus subtraction, 
works. 

This instance is immutable and unaffected by this method call. 


    amountToSubtract - the amount of the unit to subtract from the result, may be negative 
    unit - the unit of the amount to subtract, not null 

    Returns: a {@code LocalDate} based on this date with the specified amount subtracted, 
             not null 

*java.time.LocalDate.minus(TemporalAmount)*

public |java.time.LocalDate| minus(java.time.temporal.TemporalAmount amountToSubtract)

Returns a copy of this date with the specified amount subtracted. 

This returns aLocalDate, based on this one, with the specified amount 
subtracted. The amount is typically (|java.time.Period|) but may be any other 
type implementing the (|java.time.temporal.TemporalAmount|) interface. 

The calculation is delegated to the amount object by calling 
(|java.time.temporal.TemporalAmount|) . The amount implementation is free to 
implement the subtraction in any way it wishes, however it typically calls back 
to (|java.time.LocalDate|) . Consult the documentation of the amount 
implementation to determine if it can be successfully subtracted. 

This instance is immutable and unaffected by this method call. 


    amountToSubtract - the amount to subtract, not null 

    Returns: a {@code LocalDate} based on this date with the subtraction made, not null 

*java.time.LocalDate.minusDays(long)*

public |java.time.LocalDate| minusDays(long daysToSubtract)

Returns a copy of thisLocalDatewith the specified number of days subtracted. 

This method subtracts the specified amount from the days field decrementing the 
month and year fields as necessary to ensure the result remains valid. The 
result is only invalid if the maximum/minimum year is exceeded. 

For example, 2009-01-01 minus one day would result in 2008-12-31. 

This instance is immutable and unaffected by this method call. 


    daysToSubtract - the days to subtract, may be negative 

    Returns: a {@code LocalDate} based on this date with the days subtracted, not null 

*java.time.LocalDate.minusMonths(long)*

public |java.time.LocalDate| minusMonths(long monthsToSubtract)

Returns a copy of thisLocalDatewith the specified period in months subtracted. 

This method subtracts the specified amount from the months field in three 
steps: 

Subtract the input months to the month-of-year field Check if the resulting 
date would be invalid Adjust the day-of-month to the last valid day if 
necessary 

For example, 2007-03-31 minus one month would result in the invalid date 
2007-02-31. Instead of returning an invalid result, the last valid day of the 
month, 2007-02-28, is selected instead. 

This instance is immutable and unaffected by this method call. 


    monthsToSubtract - the months to subtract, may be negative 

    Returns: a {@code LocalDate} based on this date with the months subtracted, not null 

*java.time.LocalDate.minusWeeks(long)*

public |java.time.LocalDate| minusWeeks(long weeksToSubtract)

Returns a copy of thisLocalDatewith the specified period in weeks subtracted. 

This method subtracts the specified amount in weeks from the days field 
decrementing the month and year fields as necessary to ensure the result 
remains valid. The result is only invalid if the maximum/minimum year is 
exceeded. 

For example, 2009-01-07 minus one week would result in 2008-12-31. 

This instance is immutable and unaffected by this method call. 


    weeksToSubtract - the weeks to subtract, may be negative 

    Returns: a {@code LocalDate} based on this date with the weeks subtracted, not null 

*java.time.LocalDate.minusYears(long)*

public |java.time.LocalDate| minusYears(long yearsToSubtract)

Returns a copy of thisLocalDatewith the specified period in years subtracted. 

This method subtracts the specified amount from the years field in three steps: 

Subtract the input years to the year field Check if the resulting date would be 
invalid Adjust the day-of-month to the last valid day if necessary 

For example, 2008-02-29 (leap year) minus one year would result in the invalid 
date 2007-02-29 (standard year). Instead of returning an invalid result, the 
last valid day of the month, 2007-02-28, is selected instead. 

This instance is immutable and unaffected by this method call. 


    yearsToSubtract - the years to subtract, may be negative 

    Returns: a {@code LocalDate} based on this date with the years subtracted, not null 

*java.time.LocalDate.now()*

public static |java.time.LocalDate| now()

Obtains the current date from the system clock in the default time-zone. 

This will query the system clock(|java.time.Clock|) in the default time-zone to 
obtain the current date. 

Using this method will prevent the ability to use an alternate clock for 
testing because the clock is hard-coded. 



    Returns: the current date using the system clock and default time-zone, not null 

*java.time.LocalDate.now(Clock)*

public static |java.time.LocalDate| now(java.time.Clock clock)

Obtains the current date from the specified clock. 

This will query the specified clock to obtain the current date - today. Using 
this method allows the use of an alternate clock for testing. The alternate 
clock may be introduced using dependency injection(|java.time.Clock|) . 


    clock - the clock to use, not null 

    Returns: the current date, not null 

*java.time.LocalDate.now(ZoneId)*

public static |java.time.LocalDate| now(java.time.ZoneId zone)

Obtains the current date from the system clock in the specified time-zone. 

This will query the system clock(|java.time.Clock|) to obtain the current date. 
Specifying the time-zone avoids dependence on the default time-zone. 

Using this method will prevent the ability to use an alternate clock for 
testing because the clock is hard-coded. 


    zone - the zone ID to use, not null 

    Returns: the current date using the system clock, not null 

*java.time.LocalDate.of(int,int,int)*

public static |java.time.LocalDate| of(
  int year,
  int month,
  int dayOfMonth)

Obtains an instance ofLocalDatefrom a year, month and day. 

This returns aLocalDatewith the specified year, month and day-of-month. The day 
must be valid for the year and month, otherwise an exception will be thrown. 


    year - the year to represent, from MIN_YEAR to MAX_YEAR 
    month - the month-of-year to represent, from 1 (January) to 12 (December) 
    dayOfMonth - the day-of-month to represent, from 1 to 31 

    Returns: the local date, not null 

*java.time.LocalDate.of(int,Month,int)*

public static |java.time.LocalDate| of(
  int year,
  java.time.Month month,
  int dayOfMonth)

Obtains an instance ofLocalDatefrom a year, month and day. 

This returns aLocalDatewith the specified year, month and day-of-month. The day 
must be valid for the year and month, otherwise an exception will be thrown. 


    year - the year to represent, from MIN_YEAR to MAX_YEAR 
    month - the month-of-year to represent, not null 
    dayOfMonth - the day-of-month to represent, from 1 to 31 

    Returns: the local date, not null 

*java.time.LocalDate.ofEpochDay(long)*

public static |java.time.LocalDate| ofEpochDay(long epochDay)

Obtains an instance ofLocalDatefrom the epoch day count. 

This returns aLocalDatewith the specified epoch-day. The 
EPOCH_DAY(|java.time.temporal.ChronoField|) is a simple incrementing count of 
days where day 0 is 1970-01-01. Negative numbers represent earlier days. 


    epochDay - the Epoch Day to convert, based on the epoch 1970-01-01 

    Returns: the local date, not null 

*java.time.LocalDate.ofYearDay(int,int)*

public static |java.time.LocalDate| ofYearDay(
  int year,
  int dayOfYear)

Obtains an instance ofLocalDatefrom a year and day-of-year. 

This returns aLocalDatewith the specified year and day-of-year. The day-of-year 
must be valid for the year, otherwise an exception will be thrown. 


    year - the year to represent, from MIN_YEAR to MAX_YEAR 
    dayOfYear - the day-of-year to represent, from 1 to 366 

    Returns: the local date, not null 

*java.time.LocalDate.parse(CharSequence)*

public static |java.time.LocalDate| parse(java.lang.CharSequence text)

Obtains an instance ofLocalDatefrom a text string such as2007-12-03. 

The string must represent a valid date and is parsed using 
(|java.time.format.DateTimeFormatter|) . 


    text - the text to parse such as "2007-12-03", not null 

    Returns: the parsed local date, not null 

*java.time.LocalDate.parse(CharSequence,DateTimeFormatter)*

public static |java.time.LocalDate| parse(
  java.lang.CharSequence text,
  java.time.format.DateTimeFormatter formatter)

Obtains an instance ofLocalDatefrom a text string using a specific formatter. 

The text is parsed using the formatter, returning a date. 


    text - the text to parse, not null 
    formatter - the formatter to use, not null 

    Returns: the parsed local date, not null 

*java.time.LocalDate.plus(long,TemporalUnit)*

public |java.time.LocalDate| plus(
  long amountToAdd,
  java.time.temporal.TemporalUnit unit)

Returns a copy of this date with the specified amount added. 

This returns aLocalDate, based on this one, with the amount in terms of the 
unit added. If it is not possible to add the amount, because the unit is not 
supported or for some other reason, an exception is thrown. 

In some cases, adding the amount can cause the resulting date to become 
invalid. For example, adding one month to 31st January would result in 31st 
February. In cases like this, the unit is responsible for resolving the date. 
Typically it will choose the previous valid date, which would be the last valid 
day of February in this example. 

If the field is a (|java.time.temporal.ChronoUnit|) then the addition is 
implemented here. The supported fields behave as follows: 

DAYS- Returns aLocalDatewith the specified number of days added. This is 
equivalent to (|java.time.LocalDate|) . WEEKS- Returns aLocalDatewith the 
specified number of weeks added. This is equivalent to (|java.time.LocalDate|) 
and uses a 7 day week. MONTHS- Returns aLocalDatewith the specified number of 
months added. This is equivalent to (|java.time.LocalDate|) . The day-of-month 
will be unchanged unless it would be invalid for the new month and year. In 
that case, the day-of-month is adjusted to the maximum valid value for the new 
month and year. YEARS- Returns aLocalDatewith the specified number of years 
added. This is equivalent to (|java.time.LocalDate|) . The day-of-month will be 
unchanged unless it would be invalid for the new month and year. In that case, 
the day-of-month is adjusted to the maximum valid value for the new month and 
year. DECADES- Returns aLocalDatewith the specified number of decades added. 
This is equivalent to calling (|java.time.LocalDate|) with the amount 
multiplied by 10. The day-of-month will be unchanged unless it would be invalid 
for the new month and year. In that case, the day-of-month is adjusted to the 
maximum valid value for the new month and year. CENTURIES- Returns 
aLocalDatewith the specified number of centuries added. This is equivalent to 
calling (|java.time.LocalDate|) with the amount multiplied by 100. The 
day-of-month will be unchanged unless it would be invalid for the new month and 
year. In that case, the day-of-month is adjusted to the maximum valid value for 
the new month and year. MILLENNIA- Returns aLocalDatewith the specified number 
of millennia added. This is equivalent to calling (|java.time.LocalDate|) with 
the amount multiplied by 1,000. The day-of-month will be unchanged unless it 
would be invalid for the new month and year. In that case, the day-of-month is 
adjusted to the maximum valid value for the new month and year. ERAS- Returns 
aLocalDatewith the specified number of eras added. Only two eras are supported 
so the amount must be one, zero or minus one. If the amount is non-zero then 
the year is changed such that the year-of-era is unchanged. The day-of-month 
will be unchanged unless it would be invalid for the new month and year. In 
that case, the day-of-month is adjusted to the maximum valid value for the new 
month and year. 

All otherChronoUnitinstances will throw anUnsupportedTemporalTypeException. 

If the field is not aChronoUnit, then the result of this method is obtained by 
invokingTemporalUnit.addTo(Temporal, long)passingthisas the argument. In this 
case, the unit determines whether and how to perform the addition. 

This instance is immutable and unaffected by this method call. 


    amountToAdd - the amount of the unit to add to the result, may be negative 
    unit - the unit of the amount to add, not null 

    Returns: a {@code LocalDate} based on this date with the specified amount added, not 
             null 

*java.time.LocalDate.plus(TemporalAmount)*

public |java.time.LocalDate| plus(java.time.temporal.TemporalAmount amountToAdd)

Returns a copy of this date with the specified amount added. 

This returns aLocalDate, based on this one, with the specified amount added. 
The amount is typically (|java.time.Period|) but may be any other type 
implementing the (|java.time.temporal.TemporalAmount|) interface. 

The calculation is delegated to the amount object by calling 
(|java.time.temporal.TemporalAmount|) . The amount implementation is free to 
implement the addition in any way it wishes, however it typically calls back to 
(|java.time.LocalDate|) . Consult the documentation of the amount 
implementation to determine if it can be successfully added. 

This instance is immutable and unaffected by this method call. 


    amountToAdd - the amount to add, not null 

    Returns: a {@code LocalDate} based on this date with the addition made, not null 

*java.time.LocalDate.plusDays(long)*

public |java.time.LocalDate| plusDays(long daysToAdd)

Returns a copy of thisLocalDatewith the specified number of days added. 

This method adds the specified amount to the days field incrementing the month 
and year fields as necessary to ensure the result remains valid. The result is 
only invalid if the maximum/minimum year is exceeded. 

For example, 2008-12-31 plus one day would result in 2009-01-01. 

This instance is immutable and unaffected by this method call. 


    daysToAdd - the days to add, may be negative 

    Returns: a {@code LocalDate} based on this date with the days added, not null 

*java.time.LocalDate.plusMonths(long)*

public |java.time.LocalDate| plusMonths(long monthsToAdd)

Returns a copy of thisLocalDatewith the specified period in months added. 

This method adds the specified amount to the months field in three steps: 

Add the input months to the month-of-year field Check if the resulting date 
would be invalid Adjust the day-of-month to the last valid day if necessary 

For example, 2007-03-31 plus one month would result in the invalid date 
2007-04-31. Instead of returning an invalid result, the last valid day of the 
month, 2007-04-30, is selected instead. 

This instance is immutable and unaffected by this method call. 


    monthsToAdd - the months to add, may be negative 

    Returns: a {@code LocalDate} based on this date with the months added, not null 

*java.time.LocalDate.plusWeeks(long)*

public |java.time.LocalDate| plusWeeks(long weeksToAdd)

Returns a copy of thisLocalDatewith the specified period in weeks added. 

This method adds the specified amount in weeks to the days field incrementing 
the month and year fields as necessary to ensure the result remains valid. The 
result is only invalid if the maximum/minimum year is exceeded. 

For example, 2008-12-31 plus one week would result in 2009-01-07. 

This instance is immutable and unaffected by this method call. 


    weeksToAdd - the weeks to add, may be negative 

    Returns: a {@code LocalDate} based on this date with the weeks added, not null 

*java.time.LocalDate.plusYears(long)*

public |java.time.LocalDate| plusYears(long yearsToAdd)

Returns a copy of thisLocalDatewith the specified period in years added. 

This method adds the specified amount to the years field in three steps: 

Add the input years to the year field Check if the resulting date would be 
invalid Adjust the day-of-month to the last valid day if necessary 

For example, 2008-02-29 (leap year) plus one year would result in the invalid 
date 2009-02-29 (standard year). Instead of returning an invalid result, the 
last valid day of the month, 2009-02-28, is selected instead. 

This instance is immutable and unaffected by this method call. 


    yearsToAdd - the years to add, may be negative 

    Returns: a {@code LocalDate} based on this date with the years added, not null 

*java.time.LocalDate.query(TemporalQuery<R>)*

public |R| query(java.time.temporal.TemporalQuery<R> query)

Queries this date using the specified query. 

This queries this date using the specified query strategy object. 
TheTemporalQueryobject defines the logic to be used to obtain the result. Read 
the documentation of the query to understand what the result of this method 
will be. 

The result of this method is obtained by invoking the 
(|java.time.temporal.TemporalQuery|) method on the specified query 
passingthisas the argument. 


    query - the query to invoke, not null 

    Returns: the query result, null may be returned (defined by the query) 

*java.time.LocalDate.range(TemporalField)*

public |java.time.temporal.ValueRange| range(java.time.temporal.TemporalField field)

Gets the range of valid values for the specified field. 

The range object expresses the minimum and maximum valid values for a field. 
This date is used to enhance the accuracy of the returned range. If it is not 
possible to return the range, because the field is not supported or for some 
other reason, an exception is thrown. 

If the field is a (|java.time.temporal.ChronoField|) then the query is 
implemented here. The supported fields(|java.time.LocalDate|) will return 
appropriate range instances. All otherChronoFieldinstances will throw 
anUnsupportedTemporalTypeException. 

If the field is not aChronoField, then the result of this method is obtained by 
invokingTemporalField.rangeRefinedBy(TemporalAccessor)passingthisas the 
argument. Whether the range can be obtained is determined by the field. 


    field - the field to query the range for, not null 

    Returns: the range of valid values for the field, not null 

*java.time.LocalDate.toEpochDay()*

public long toEpochDay()





*java.time.LocalDate.toString()*

public |java.lang.String| toString()

Outputs this date as aString, such as2007-12-03. 

The output will be in the ISO-8601 formatuuuu-MM-dd. 



    Returns: a string representation of this date, not null 

*java.time.LocalDate.until(ChronoLocalDate)*

public |java.time.Period| until(java.time.chrono.ChronoLocalDate endDateExclusive)

Calculates the period between this date and another date as aPeriod. 

This calculates the period between two dates in terms of years, months and 
days. The start and end points arethisand the specified date. The result will 
be negative if the end is before the start. The negative sign will be the same 
in each of year, month and day. 

The calculation is performed using the ISO calendar system. If necessary, the 
input date will be converted to ISO. 

The start date is included, but the end date is not. The period is calculated 
by removing complete months, then calculating the remaining number of days, 
adjusting to ensure that both have the same sign. The number of months is then 
normalized into years and months based on a 12 month year. A month is 
considered to be complete if the end day-of-month is greater than or equal to 
the start day-of-month. For example, from2010-01-15to2011-03-18is "1 year, 2 
months and 3 days". 

There are two equivalent ways of using this method. The first is to invoke this 
method. The second is to use (|java.time.Period|) : 

// these two lines are equivalent period = start.until(end); period = 
Period.between(start, end); 

The choice should be made based on which makes the code more readable. 


    endDateExclusive - the end date, exclusive, which may be in any chronology, not null 

    Returns: the period between this date and the end date, not null 

*java.time.LocalDate.until(Temporal,TemporalUnit)*

public long until(
  java.time.temporal.Temporal endExclusive,
  java.time.temporal.TemporalUnit unit)

Calculates the amount of time until another date in terms of the specified 
unit. 

This calculates the amount of time between twoLocalDateobjects in terms of a 
singleTemporalUnit. The start and end points arethisand the specified date. The 
result will be negative if the end is before the start. TheTemporalpassed to 
this method is converted to aLocalDateusing (|java.time.LocalDate|) . For 
example, the amount in days between two dates can be calculated 
usingstartDate.until(endDate, DAYS). 

The calculation returns a whole number, representing the number of complete 
units between the two dates. For example, the amount in months between 
2012-06-15 and 2012-08-14 will only be one month as it is one day short of two 
months. 

There are two equivalent ways of using this method. The first is to invoke this 
method. The second is to use (|java.time.temporal.TemporalUnit|) : 

// these two lines are equivalent amount = start.until(end, MONTHS); amount = 
MONTHS.between(start, end); 

The choice should be made based on which makes the code more readable. 

The calculation is implemented in this method for 
(|java.time.temporal.ChronoUnit|) . The 
unitsDAYS,WEEKS,MONTHS,YEARS,DECADES,CENTURIES,MILLENNIAandERASare supported. 
OtherChronoUnitvalues will throw an exception. 

If the unit is not aChronoUnit, then the result of this method is obtained by 
invokingTemporalUnit.between(Temporal, Temporal)passingthisas the first 
argument and the converted input temporal as the second argument. 

This instance is immutable and unaffected by this method call. 


    endExclusive - the end date, exclusive, which is converted to a {@code LocalDate}, not null 
    unit - the unit to measure the amount in, not null 

    Returns: the amount of time between this date and the end date 

*java.time.LocalDate.with(TemporalAdjuster)*

public |java.time.LocalDate| with(java.time.temporal.TemporalAdjuster adjuster)

Returns an adjusted copy of this date. 

This returns aLocalDate, based on this one, with the date adjusted. The 
adjustment takes place using the specified adjuster strategy object. Read the 
documentation of the adjuster to understand what adjustment will be made. 

A simple adjuster might simply set the one of the fields, such as the year 
field. A more complex adjuster might set the date to the last day of the month. 
A selection of common adjustments is provided in 
(|java.time.temporal.TemporalAdjuster|) . These include finding the "last day 
of the month" and "next Wednesday". Key date-time classes also implement 
theTemporalAdjusterinterface, such as (|java.time.Month|) and 
MonthDay(|java.time.MonthDay|) . The adjuster is responsible for handling 
special cases, such as the varying lengths of month and leap years. 

For example this code returns a date on the last day of July: 

import static java.time.Month.*; import static java.time.temporal.Adjusters.*; 

result = localDate.with(JULY).with(lastDayOfMonth()); 

The result of this method is obtained by invoking the 
(|java.time.temporal.TemporalAdjuster|) method on the specified adjuster 
passingthisas the argument. 

This instance is immutable and unaffected by this method call. 


    adjuster - the adjuster to use, not null 

    Returns: a {@code LocalDate} based on {@code this} with the adjustment made, not null 

*java.time.LocalDate.with(TemporalField,long)*

public |java.time.LocalDate| with(
  java.time.temporal.TemporalField field,
  long newValue)

Returns a copy of this date with the specified field set to a new value. 

This returns aLocalDate, based on this one, with the value for the specified 
field changed. This can be used to change any supported field, such as the 
year, month or day-of-month. If it is not possible to set the value, because 
the field is not supported or for some other reason, an exception is thrown. 

In some cases, changing the specified field can cause the resulting date to 
become invalid, such as changing the month from 31st January to February would 
make the day-of-month invalid. In cases like this, the field is responsible for 
resolving the date. Typically it will choose the previous valid date, which 
would be the last valid day of February in this example. 

If the field is a (|java.time.temporal.ChronoField|) then the adjustment is 
implemented here. The supported fields behave as follows: 

DAY_OF_WEEK- Returns aLocalDatewith the specified day-of-week. The date is 
adjusted up to 6 days forward or backward within the boundary of a Monday to 
Sunday week. ALIGNED_DAY_OF_WEEK_IN_MONTH- Returns aLocalDatewith the specified 
aligned-day-of-week. The date is adjusted to the specified month-based 
aligned-day-of-week. Aligned weeks are counted such that the first week of a 
given month starts on the first day of that month. This may cause the date to 
be moved up to 6 days into the following month. ALIGNED_DAY_OF_WEEK_IN_YEAR- 
Returns aLocalDatewith the specified aligned-day-of-week. The date is adjusted 
to the specified year-based aligned-day-of-week. Aligned weeks are counted such 
that the first week of a given year starts on the first day of that year. This 
may cause the date to be moved up to 6 days into the following year. 
DAY_OF_MONTH- Returns aLocalDatewith the specified day-of-month. The month and 
year will be unchanged. If the day-of-month is invalid for the year and month, 
then aDateTimeExceptionis thrown. DAY_OF_YEAR- Returns aLocalDatewith the 
specified day-of-year. The year will be unchanged. If the day-of-year is 
invalid for the year, then aDateTimeExceptionis thrown. EPOCH_DAY- Returns 
aLocalDatewith the specified epoch-day. This completely replaces the date and 
is equivalent to (|java.time.LocalDate|) . ALIGNED_WEEK_OF_MONTH- Returns 
aLocalDatewith the specified aligned-week-of-month. Aligned weeks are counted 
such that the first week of a given month starts on the first day of that 
month. This adjustment moves the date in whole week chunks to match the 
specified week. The result will have the same day-of-week as this date. This 
may cause the date to be moved into the following month. ALIGNED_WEEK_OF_YEAR- 
Returns aLocalDatewith the specified aligned-week-of-year. Aligned weeks are 
counted such that the first week of a given year starts on the first day of 
that year. This adjustment moves the date in whole week chunks to match the 
specified week. The result will have the same day-of-week as this date. This 
may cause the date to be moved into the following year. MONTH_OF_YEAR- Returns 
aLocalDatewith the specified month-of-year. The year will be unchanged. The 
day-of-month will also be unchanged, unless it would be invalid for the new 
month and year. In that case, the day-of-month is adjusted to the maximum valid 
value for the new month and year. PROLEPTIC_MONTH- Returns aLocalDatewith the 
specified proleptic-month. The day-of-month will be unchanged, unless it would 
be invalid for the new month and year. In that case, the day-of-month is 
adjusted to the maximum valid value for the new month and year. YEAR_OF_ERA- 
Returns aLocalDatewith the specified year-of-era. The era and month will be 
unchanged. The day-of-month will also be unchanged, unless it would be invalid 
for the new month and year. In that case, the day-of-month is adjusted to the 
maximum valid value for the new month and year. YEAR- Returns aLocalDatewith 
the specified year. The month will be unchanged. The day-of-month will also be 
unchanged, unless it would be invalid for the new month and year. In that case, 
the day-of-month is adjusted to the maximum valid value for the new month and 
year. ERA- Returns aLocalDatewith the specified era. The year-of-era and month 
will be unchanged. The day-of-month will also be unchanged, unless it would be 
invalid for the new month and year. In that case, the day-of-month is adjusted 
to the maximum valid value for the new month and year. 

In all cases, if the new value is outside the valid range of values for the 
field then aDateTimeExceptionwill be thrown. 

All otherChronoFieldinstances will throw anUnsupportedTemporalTypeException. 

If the field is not aChronoField, then the result of this method is obtained by 
invokingTemporalField.adjustInto(Temporal, long)passingthisas the argument. In 
this case, the field determines whether and how to adjust the instant. 

This instance is immutable and unaffected by this method call. 


    field - the field to set in the result, not null 
    newValue - the new value of the field in the result 

    Returns: a {@code LocalDate} based on {@code this} with the specified field set, not 
             null 

*java.time.LocalDate.withDayOfMonth(int)*

public |java.time.LocalDate| withDayOfMonth(int dayOfMonth)

Returns a copy of this date with the day-of-month altered. If the resulting 
date is invalid, an exception is thrown. 

This instance is immutable and unaffected by this method call. 


    dayOfMonth - the day-of-month to set in the result, from 1 to 28-31 

    Returns: a {@code LocalDate} based on this date with the requested day, not null 

*java.time.LocalDate.withDayOfYear(int)*

public |java.time.LocalDate| withDayOfYear(int dayOfYear)

Returns a copy of this date with the day-of-year altered. If the resulting date 
is invalid, an exception is thrown. 

This instance is immutable and unaffected by this method call. 


    dayOfYear - the day-of-year to set in the result, from 1 to 365-366 

    Returns: a {@code LocalDate} based on this date with the requested day, not null 

*java.time.LocalDate.withMonth(int)*

public |java.time.LocalDate| withMonth(int month)

Returns a copy of this date with the month-of-year altered. If the day-of-month 
is invalid for the year, it will be changed to the last valid day of the month. 

This instance is immutable and unaffected by this method call. 


    month - the month-of-year to set in the result, from 1 (January) to 12 (December) 

    Returns: a {@code LocalDate} based on this date with the requested month, not null 

*java.time.LocalDate.withYear(int)*

public |java.time.LocalDate| withYear(int year)

Returns a copy of this date with the year altered. If the day-of-month is 
invalid for the year, it will be changed to the last valid day of the month. 

This instance is immutable and unaffected by this method call. 


    year - the year to set in the result, from MIN_YEAR to MAX_YEAR 

    Returns: a {@code LocalDate} based on this date with the requested year, not null 


