*java.time.ZonedDateTime* *ZonedDateTime* A date-time with a time-zone in the IS

public final class ZonedDateTime
  extends    |java.lang.Object|
  implements |java.time.temporal.Temporal|
             |java.time.chrono.ChronoZonedDateTime|
             |java.io.Serializable|

|java.time.ZonedDateTime_Description|
|java.time.ZonedDateTime_Fields|
|java.time.ZonedDateTime_Constructors|
|java.time.ZonedDateTime_Methods|

================================================================================

*java.time.ZonedDateTime_Methods*
|java.time.ZonedDateTime.equals(Object)|Checks if this date-time is equal to an
|java.time.ZonedDateTime.format(DateTimeFormatter)|Formats this date-time using
|java.time.ZonedDateTime.from(TemporalAccessor)|Obtains an instance ofZonedDate
|java.time.ZonedDateTime.get(TemporalField)|Gets the value of the specified fie
|java.time.ZonedDateTime.getDayOfMonth()|Gets the day-of-month field.
|java.time.ZonedDateTime.getDayOfWeek()|Gets the day-of-week field, which is an
|java.time.ZonedDateTime.getDayOfYear()|Gets the day-of-year field.
|java.time.ZonedDateTime.getHour()|Gets the hour-of-day field.
|java.time.ZonedDateTime.getLong(TemporalField)|Gets the value of the specified
|java.time.ZonedDateTime.getMinute()|Gets the minute-of-hour field.
|java.time.ZonedDateTime.getMonth()|Gets the month-of-year field using theMonth
|java.time.ZonedDateTime.getMonthValue()|Gets the month-of-year field from 1 to
|java.time.ZonedDateTime.getNano()|Gets the nano-of-second field.
|java.time.ZonedDateTime.getOffset()|Gets the zone offset, such as '+01:00'.
|java.time.ZonedDateTime.getSecond()|Gets the second-of-minute field.
|java.time.ZonedDateTime.getYear()|Gets the year field.
|java.time.ZonedDateTime.getZone()|Gets the time-zone, such as 'Europe/Paris'.
|java.time.ZonedDateTime.hashCode()|A hash code for this date-time.
|java.time.ZonedDateTime.isSupported(TemporalField)|Checks if the specified fie
|java.time.ZonedDateTime.isSupported(TemporalUnit)|Checks if the specified unit
|java.time.ZonedDateTime.minus(long,TemporalUnit)|Returns a copy of this date-t
|java.time.ZonedDateTime.minus(TemporalAmount)|Returns a copy of this date-time
|java.time.ZonedDateTime.minusDays(long)|Returns a copy of thisZonedDateTimewit
|java.time.ZonedDateTime.minusHours(long)|Returns a copy of thisZonedDateTimewi
|java.time.ZonedDateTime.minusMinutes(long)|Returns a copy of thisZonedDateTime
|java.time.ZonedDateTime.minusMonths(long)|Returns a copy of thisZonedDateTimew
|java.time.ZonedDateTime.minusNanos(long)|Returns a copy of thisZonedDateTimewi
|java.time.ZonedDateTime.minusSeconds(long)|Returns a copy of thisZonedDateTime
|java.time.ZonedDateTime.minusWeeks(long)|Returns a copy of thisZonedDateTimewi
|java.time.ZonedDateTime.minusYears(long)|Returns a copy of thisZonedDateTimewi
|java.time.ZonedDateTime.now()|Obtains the current date-time from the system cl
|java.time.ZonedDateTime.now(Clock)|Obtains the current date-time from the spec
|java.time.ZonedDateTime.now(ZoneId)|Obtains the current date-time from the sys
|java.time.ZonedDateTime.of(int,int,int,int,int,int,int,ZoneId)|Obtains an inst
|java.time.ZonedDateTime.of(LocalDate,LocalTime,ZoneId)|Obtains an instance ofZ
|java.time.ZonedDateTime.of(LocalDateTime,ZoneId)|Obtains an instance ofZonedDa
|java.time.ZonedDateTime.ofInstant(Instant,ZoneId)|Obtains an instance ofZonedD
|java.time.ZonedDateTime.ofInstant(LocalDateTime,ZoneOffset,ZoneId)|Obtains an 
|java.time.ZonedDateTime.ofLocal(LocalDateTime,ZoneId,ZoneOffset)|Obtains an in
|java.time.ZonedDateTime.ofStrict(LocalDateTime,ZoneOffset,ZoneId)|Obtains an i
|java.time.ZonedDateTime.parse(CharSequence)|Obtains an instance ofZonedDateTim
|java.time.ZonedDateTime.parse(CharSequence,DateTimeFormatter)|Obtains an insta
|java.time.ZonedDateTime.plus(long,TemporalUnit)|Returns a copy of this date-ti
|java.time.ZonedDateTime.plus(TemporalAmount)|Returns a copy of this date-time 
|java.time.ZonedDateTime.plusDays(long)|Returns a copy of thisZonedDateTimewith
|java.time.ZonedDateTime.plusHours(long)|Returns a copy of thisZonedDateTimewit
|java.time.ZonedDateTime.plusMinutes(long)|Returns a copy of thisZonedDateTimew
|java.time.ZonedDateTime.plusMonths(long)|Returns a copy of thisZonedDateTimewi
|java.time.ZonedDateTime.plusNanos(long)|Returns a copy of thisZonedDateTimewit
|java.time.ZonedDateTime.plusSeconds(long)|Returns a copy of thisZonedDateTimew
|java.time.ZonedDateTime.plusWeeks(long)|Returns a copy of thisZonedDateTimewit
|java.time.ZonedDateTime.plusYears(long)|Returns a copy of thisZonedDateTimewit
|java.time.ZonedDateTime.query(TemporalQuery<R>)|Queries this date-time using t
|java.time.ZonedDateTime.range(TemporalField)|Gets the range of valid values fo
|java.time.ZonedDateTime.toLocalDate()|Gets theLocalDatepart of this date-time.
|java.time.ZonedDateTime.toLocalDateTime()|Gets theLocalDateTimepart of this da
|java.time.ZonedDateTime.toLocalTime()|Gets theLocalTimepart of this date-time.
|java.time.ZonedDateTime.toOffsetDateTime()|Converts this date-time to anOffset
|java.time.ZonedDateTime.toString()|Outputs this date-time as aString, such as2
|java.time.ZonedDateTime.truncatedTo(TemporalUnit)|Returns a copy of thisZonedD
|java.time.ZonedDateTime.until(Temporal,TemporalUnit)|Calculates the amount of 
|java.time.ZonedDateTime.with(TemporalAdjuster)|Returns an adjusted copy of thi
|java.time.ZonedDateTime.with(TemporalField,long)|Returns a copy of this date-t
|java.time.ZonedDateTime.withDayOfMonth(int)|Returns a copy of thisZonedDateTim
|java.time.ZonedDateTime.withDayOfYear(int)|Returns a copy of thisZonedDateTime
|java.time.ZonedDateTime.withEarlierOffsetAtOverlap()|Returns a copy of this da
|java.time.ZonedDateTime.withFixedOffsetZone()|Returns a copy of this date-time
|java.time.ZonedDateTime.withHour(int)|Returns a copy of thisZonedDateTimewith 
|java.time.ZonedDateTime.withLaterOffsetAtOverlap()|Returns a copy of this date
|java.time.ZonedDateTime.withMinute(int)|Returns a copy of thisZonedDateTimewit
|java.time.ZonedDateTime.withMonth(int)|Returns a copy of thisZonedDateTimewith
|java.time.ZonedDateTime.withNano(int)|Returns a copy of thisZonedDateTimewith 
|java.time.ZonedDateTime.withSecond(int)|Returns a copy of thisZonedDateTimewit
|java.time.ZonedDateTime.withYear(int)|Returns a copy of thisZonedDateTimewith 
|java.time.ZonedDateTime.withZoneSameInstant(ZoneId)|Returns a copy of this dat
|java.time.ZonedDateTime.withZoneSameLocal(ZoneId)|Returns a copy of this date-

*java.time.ZonedDateTime_Description*

A date-time with a time-zone in the ISO-8601 calendar system, such 
as2007-12-03T10:15:30+01:00 Europe/Paris. ZonedDateTimeis an immutable 
representation of a date-time with a time-zone. This class stores all date and 
time fields, to a precision of nanoseconds, and a time-zone, with a zone offset 
used to handle ambiguous local date-times. For example, the value "2nd October 
2007 at 13:45.30.123456789 +02:00 in the Europe/Paris time-zone" can be stored 
in aZonedDateTime. 

This class handles conversion from the local time-line ofLocalDateTimeto the 
instant time-line ofInstant. The difference between the two time-lines is the 
offset from UTC/Greenwich, represented by aZoneOffset. 

Converting between the two time-lines involves calculating the offset using the 
rules(|java.time.zone.ZoneRules|) accessed from theZoneId. Obtaining the offset 
for an instant is simple, as there is exactly one valid offset for each 
instant. By contrast, obtaining the offset for a local date-time is not 
straightforward. There are three cases: 

Normal, with one valid offset. For the vast majority of the year, the normal 
case applies, where there is a single valid offset for the local date-time. 
Gap, with zero valid offsets. This is when clocks jump forward typically due to 
the spring daylight savings change from "winter" to "summer". In a gap there 
are local date-time values with no valid offset. Overlap, with two valid 
offsets. This is when clocks are set back typically due to the autumn daylight 
savings change from "summer" to "winter". In an overlap there are local 
date-time values with two valid offsets. 

Any method that converts directly or implicitly from a local date-time to an 
instant by obtaining the offset has the potential to be complicated. 

For Gaps, the general strategy is that if the local date-time falls in the 
middle of a Gap, then the resulting zoned date-time will have a local date-time 
shifted forwards by the length of the Gap, resulting in a date-time in the 
later offset, typically "summer" time. 

For Overlaps, the general strategy is that if the local date-time falls in the 
middle of an Overlap, then the previous offset will be retained. If there is no 
previous offset, or the previous offset is invalid, then the earlier offset is 
used, typically "summer" time.. Two additional methods, 
(|java.time.ZonedDateTime|) and (|java.time.ZonedDateTime|) , help manage the 
case of an overlap. 

In terms of design, this class should be viewed primarily as the combination of 
aLocalDateTimeand aZoneId. TheZoneOffsetis a vital, but secondary, piece of 
information, used to ensure that the class represents an instant, especially 
during a daylight savings overlap. 

This is a <a href="/java/lang/doc-files/ValueBased.html">value-based class; use 
of identity-sensitive operations (including reference equality (==), identity 
hash code, or synchronization) on instances ofZonedDateTimemay have 
unpredictable results and should be avoided. Theequalsmethod should be used for 
comparisons. 



*java.time.ZonedDateTime.equals(Object)*

public boolean equals(java.lang.Object obj)

Checks if this date-time is equal to another date-time. 

The comparison is based on the offset date-time and the zone. Only objects of 
typeZonedDateTimeare compared, other types return false. 


    obj - the object to check, null returns false 

    Returns: true if this is equal to the other date-time 

*java.time.ZonedDateTime.format(DateTimeFormatter)*

public |java.lang.String| format(java.time.format.DateTimeFormatter formatter)

Formats this date-time using the specified formatter. 

This date-time will be passed to the formatter to produce a string. 


    formatter - the formatter to use, not null 

    Returns: the formatted date-time string, not null 

*java.time.ZonedDateTime.from(TemporalAccessor)*

public static |java.time.ZonedDateTime| from(java.time.temporal.TemporalAccessor temporal)

Obtains an instance ofZonedDateTimefrom a temporal object. 

This obtains a zoned date-time based on the specified temporal. 
ATemporalAccessorrepresents an arbitrary set of date and time information, 
which this factory converts to an instance ofZonedDateTime. 

The conversion will first obtain aZoneIdfrom the temporal object, falling back 
to aZoneOffsetif necessary. It will then try to obtain anInstant, falling back 
to aLocalDateTimeif necessary. The result will be either the combination 
ofZoneIdorZoneOffsetwithInstantorLocalDateTime. Implementations are permitted 
to perform optimizations such as accessing those fields that are equivalent to 
the relevant objects. 

This method matches the signature of the functional interface 
(|java.time.temporal.TemporalQuery|) allowing it to be used in queries via 
method reference,ZonedDateTime::from. 


    temporal - the temporal object to convert, not null 

    Returns: the zoned date-time, not null 

*java.time.ZonedDateTime.get(TemporalField)*

public int get(java.time.temporal.TemporalField field)

Gets the value of the specified field from this date-time as anint. 

This queries this date-time for the value for the specified field. The returned 
value will always be within the valid range of values for the field. If it is 
not possible to return the value, because the field is not supported or for 
some other reason, an exception is thrown. 

If the field is a (|java.time.temporal.ChronoField|) then the query is 
implemented here. The supported fields(|java.time.ZonedDateTime|) will return 
valid values based on this date-time, 
exceptNANO_OF_DAY,MICRO_OF_DAY,EPOCH_DAY,PROLEPTIC_MONTHandINSTANT_SECONDSwhich 
are too large to fit in anintand throw aDateTimeException. All 
otherChronoFieldinstances will throw anUnsupportedTemporalTypeException. 

If the field is not aChronoField, then the result of this method is obtained by 
invokingTemporalField.getFrom(TemporalAccessor)passingthisas the argument. 
Whether the value can be obtained, and what the value represents, is determined 
by the field. 


    field - the field to get, not null 

    Returns: the value for the field 

*java.time.ZonedDateTime.getDayOfMonth()*

public int getDayOfMonth()

Gets the day-of-month field. 

This method returns the primitiveintvalue for the day-of-month. 



    Returns: the day-of-month, from 1 to 31 

*java.time.ZonedDateTime.getDayOfWeek()*

public |java.time.DayOfWeek| getDayOfWeek()

Gets the day-of-week field, which is an enumDayOfWeek. 

This method returns the enum (|java.time.DayOfWeek|) for the day-of-week. This 
avoids confusion as to whatintvalues mean. If you need access to the 
primitiveintvalue then the enum provides the int value(|java.time.DayOfWeek|) . 

Additional information can be obtained from theDayOfWeek. This includes textual 
names of the values. 



    Returns: the day-of-week, not null 

*java.time.ZonedDateTime.getDayOfYear()*

public int getDayOfYear()

Gets the day-of-year field. 

This method returns the primitiveintvalue for the day-of-year. 



    Returns: the day-of-year, from 1 to 365, or 366 in a leap year 

*java.time.ZonedDateTime.getHour()*

public int getHour()

Gets the hour-of-day field. 



    Returns: the hour-of-day, from 0 to 23 

*java.time.ZonedDateTime.getLong(TemporalField)*

public long getLong(java.time.temporal.TemporalField field)

Gets the value of the specified field from this date-time as along. 

This queries this date-time for the value for the specified field. If it is not 
possible to return the value, because the field is not supported or for some 
other reason, an exception is thrown. 

If the field is a (|java.time.temporal.ChronoField|) then the query is 
implemented here. The supported fields(|java.time.ZonedDateTime|) will return 
valid values based on this date-time. All otherChronoFieldinstances will throw 
anUnsupportedTemporalTypeException. 

If the field is not aChronoField, then the result of this method is obtained by 
invokingTemporalField.getFrom(TemporalAccessor)passingthisas the argument. 
Whether the value can be obtained, and what the value represents, is determined 
by the field. 


    field - the field to get, not null 

    Returns: the value for the field 

*java.time.ZonedDateTime.getMinute()*

public int getMinute()

Gets the minute-of-hour field. 



    Returns: the minute-of-hour, from 0 to 59 

*java.time.ZonedDateTime.getMonth()*

public |java.time.Month| getMonth()

Gets the month-of-year field using theMonthenum. 

This method returns the enum (|java.time.Month|) for the month. This avoids 
confusion as to whatintvalues mean. If you need access to the primitiveintvalue 
then the enum provides the int value(|java.time.Month|) . 



    Returns: the month-of-year, not null 

*java.time.ZonedDateTime.getMonthValue()*

public int getMonthValue()

Gets the month-of-year field from 1 to 12. 

This method returns the month as anintfrom 1 to 12. Application code is 
frequently clearer if the enum (|java.time.Month|) is used by calling 
(|java.time.ZonedDateTime|) . 



    Returns: the month-of-year, from 1 to 12 

*java.time.ZonedDateTime.getNano()*

public int getNano()

Gets the nano-of-second field. 



    Returns: the nano-of-second, from 0 to 999,999,999 

*java.time.ZonedDateTime.getOffset()*

public |java.time.ZoneOffset| getOffset()

Gets the zone offset, such as '+01:00'. 

This is the offset of the local date-time from UTC/Greenwich. 



    Returns: the zone offset, not null 

*java.time.ZonedDateTime.getSecond()*

public int getSecond()

Gets the second-of-minute field. 



    Returns: the second-of-minute, from 0 to 59 

*java.time.ZonedDateTime.getYear()*

public int getYear()

Gets the year field. 

This method returns the primitiveintvalue for the year. 

The year returned by this method is proleptic as perget(YEAR). To obtain the 
year-of-era, useget(YEAR_OF_ERA). 



    Returns: the year, from MIN_YEAR to MAX_YEAR 

*java.time.ZonedDateTime.getZone()*

public |java.time.ZoneId| getZone()

Gets the time-zone, such as 'Europe/Paris'. 

This returns the zone ID. This identifies the time-zone 
rules(|java.time.zone.ZoneRules|) that determine when and how the offset from 
UTC/Greenwich changes. 

The zone ID may be same as the offset(|java.time.ZonedDateTime|) . If this is 
true, then any future calculations, such as addition or subtraction, have no 
complex edge cases due to time-zone rules. See also (|java.time.ZonedDateTime|) 
. 



    Returns: the time-zone, not null 

*java.time.ZonedDateTime.hashCode()*

public int hashCode()

A hash code for this date-time. 



    Returns: a suitable hash code 

*java.time.ZonedDateTime.isSupported(TemporalField)*

public boolean isSupported(java.time.temporal.TemporalField field)

Checks if the specified field is supported. 

This checks if this date-time can be queried for the specified field. If false, 
then calling the range(|java.time.ZonedDateTime|) , 
get(|java.time.ZonedDateTime|) and (|java.time.ZonedDateTime|) methods will 
throw an exception. 

If the field is a (|java.time.temporal.ChronoField|) then the query is 
implemented here. The supported fields are: 

NANO_OF_SECONDNANO_OF_DAYMICRO_OF_SECONDMICRO_OF_DAYMILLI_OF_SECONDMILLI_OF_DAYSECOND_OF_MINUTESECOND_OF_DAYMINUTE_OF_HOURMINUTE_OF_DAYHOUR_OF_AMPMCLOCK_HOUR_OF_AMPMHOUR_OF_DAYCLOCK_HOUR_OF_DAYAMPM_OF_DAYDAY_OF_WEEKALIGNED_DAY_OF_WEEK_IN_MONTHALIGNED_DAY_OF_WEEK_IN_YEARDAY_OF_MONTHDAY_OF_YEAREPOCH_DAYALIGNED_WEEK_OF_MONTHALIGNED_WEEK_OF_YEARMONTH_OF_YEARPROLEPTIC_MONTHYEAR_OF_ERAYEARERAINSTANT_SECONDSOFFSET_SECONDS
All otherChronoFieldinstances will return false. 

If the field is not aChronoField, then the result of this method is obtained by 
invokingTemporalField.isSupportedBy(TemporalAccessor)passingthisas the 
argument. Whether the field is supported is determined by the field. 


    field - the field to check, null returns false 

    Returns: true if the field is supported on this date-time, false if not 

*java.time.ZonedDateTime.isSupported(TemporalUnit)*

public boolean isSupported(java.time.temporal.TemporalUnit unit)

Checks if the specified unit is supported. 

This checks if the specified unit can be added to, or subtracted from, this 
date-time. If false, then calling the (|java.time.ZonedDateTime|) and 
minus(|java.time.ZonedDateTime|) methods will throw an exception. 

If the unit is a (|java.time.temporal.ChronoUnit|) then the query is 
implemented here. The supported units are: 

NANOSMICROSMILLISSECONDSMINUTESHOURSHALF_DAYSDAYSWEEKSMONTHSYEARSDECADESCENTURIESMILLENNIAERAS
All otherChronoUnitinstances will return false. 

If the unit is not aChronoUnit, then the result of this method is obtained by 
invokingTemporalUnit.isSupportedBy(Temporal)passingthisas the argument. Whether 
the unit is supported is determined by the unit. 


    unit - the unit to check, null returns false 

    Returns: true if the unit can be added/subtracted, false if not 

*java.time.ZonedDateTime.minus(long,TemporalUnit)*

public |java.time.ZonedDateTime| minus(
  long amountToSubtract,
  java.time.temporal.TemporalUnit unit)

Returns a copy of this date-time with the specified amount subtracted. 

This returns aZonedDateTime, based on this one, with the amount in terms of the 
unit subtracted. If it is not possible to subtract the amount, because the unit 
is not supported or for some other reason, an exception is thrown. 

The calculation for date and time units differ. 

Date units operate on the local time-line. The period is first subtracted from 
the local date-time, then converted back to a zoned date-time using the zone 
ID. The conversion uses (|java.time.ZonedDateTime|) with the offset before the 
subtraction. 

Time units operate on the instant time-line. The period is first subtracted 
from the local date-time, then converted back to a zoned date-time using the 
zone ID. The conversion uses (|java.time.ZonedDateTime|) with the offset before 
the subtraction. 

This method is equivalent to (|java.time.ZonedDateTime|) with the amount 
negated. See that method for a full description of how addition, and thus 
subtraction, works. 

This instance is immutable and unaffected by this method call. 


    amountToSubtract - the amount of the unit to subtract from the result, may be negative 
    unit - the unit of the amount to subtract, not null 

    Returns: a {@code ZonedDateTime} based on this date-time with the specified amount 
             subtracted, not null 

*java.time.ZonedDateTime.minus(TemporalAmount)*

public |java.time.ZonedDateTime| minus(java.time.temporal.TemporalAmount amountToSubtract)

Returns a copy of this date-time with the specified amount subtracted. 

This returns aZonedDateTime, based on this one, with the specified amount 
subtracted. The amount is typically (|java.time.Period|) or 
(|java.time.Duration|) but may be any other type implementing the 
(|java.time.temporal.TemporalAmount|) interface. 

The calculation is delegated to the amount object by calling 
(|java.time.temporal.TemporalAmount|) . The amount implementation is free to 
implement the subtraction in any way it wishes, however it typically calls back 
to (|java.time.ZonedDateTime|) . Consult the documentation of the amount 
implementation to determine if it can be successfully subtracted. 

This instance is immutable and unaffected by this method call. 


    amountToSubtract - the amount to subtract, not null 

    Returns: a {@code ZonedDateTime} based on this date-time with the subtraction made, not 
             null 

*java.time.ZonedDateTime.minusDays(long)*

public |java.time.ZonedDateTime| minusDays(long days)

Returns a copy of thisZonedDateTimewith the specified period in days 
subtracted. 

This operates on the local time-line, subtracting 
days(|java.time.LocalDateTime|) to the local date-time. This is then converted 
back to aZonedDateTime, using the zone ID to obtain the offset. 

When converting back toZonedDateTime, if the local date-time is in an overlap, 
then the offset will be retained if possible, otherwise the earlier offset will 
be used. If in a gap, the local date-time will be adjusted forward by the 
length of the gap. 

This instance is immutable and unaffected by this method call. 


    days - the days to subtract, may be negative 

    Returns: a {@code ZonedDateTime} based on this date-time with the days subtracted, not 
             null 

*java.time.ZonedDateTime.minusHours(long)*

public |java.time.ZonedDateTime| minusHours(long hours)

Returns a copy of thisZonedDateTimewith the specified period in hours 
subtracted. 

This operates on the instant time-line, such that subtracting one hour will 
always be a duration of one hour earlier. This may cause the local date-time to 
change by an amount other than one hour. Note that this is a different approach 
to that used by days, months and years, thus subtracting one day is not the 
same as adding 24 hours. 

For example, consider a time-zone where the spring DST cutover means that the 
local times 01:00 to 01:59 occur twice changing from offset +02:00 to +01:00. 

Subtracting one hour from 02:30+01:00 will result in 01:30+02:00 Subtracting 
one hour from 01:30+01:00 will result in 01:30+02:00 Subtracting one hour from 
01:30+02:00 will result in 00:30+01:00 Subtracting three hours from 02:30+01:00 
will result in 00:30+02:00 

This instance is immutable and unaffected by this method call. 


    hours - the hours to subtract, may be negative 

    Returns: a {@code ZonedDateTime} based on this date-time with the hours subtracted, not 
             null 

*java.time.ZonedDateTime.minusMinutes(long)*

public |java.time.ZonedDateTime| minusMinutes(long minutes)

Returns a copy of thisZonedDateTimewith the specified period in minutes 
subtracted. 

This operates on the instant time-line, such that subtracting one minute will 
always be a duration of one minute earlier. This may cause the local date-time 
to change by an amount other than one minute. Note that this is a different 
approach to that used by days, months and years. 

This instance is immutable and unaffected by this method call. 


    minutes - the minutes to subtract, may be negative 

    Returns: a {@code ZonedDateTime} based on this date-time with the minutes subtracted, 
             not null 

*java.time.ZonedDateTime.minusMonths(long)*

public |java.time.ZonedDateTime| minusMonths(long months)

Returns a copy of thisZonedDateTimewith the specified period in months 
subtracted. 

This operates on the local time-line, subtracting 
months(|java.time.LocalDateTime|) to the local date-time. This is then 
converted back to aZonedDateTime, using the zone ID to obtain the offset. 

When converting back toZonedDateTime, if the local date-time is in an overlap, 
then the offset will be retained if possible, otherwise the earlier offset will 
be used. If in a gap, the local date-time will be adjusted forward by the 
length of the gap. 

This instance is immutable and unaffected by this method call. 


    months - the months to subtract, may be negative 

    Returns: a {@code ZonedDateTime} based on this date-time with the months subtracted, not 
             null 

*java.time.ZonedDateTime.minusNanos(long)*

public |java.time.ZonedDateTime| minusNanos(long nanos)

Returns a copy of thisZonedDateTimewith the specified period in nanoseconds 
subtracted. 

This operates on the instant time-line, such that subtracting one nano will 
always be a duration of one nano earlier. This may cause the local date-time to 
change by an amount other than one nano. Note that this is a different approach 
to that used by days, months and years. 

This instance is immutable and unaffected by this method call. 


    nanos - the nanos to subtract, may be negative 

    Returns: a {@code ZonedDateTime} based on this date-time with the nanoseconds 
             subtracted, not null 

*java.time.ZonedDateTime.minusSeconds(long)*

public |java.time.ZonedDateTime| minusSeconds(long seconds)

Returns a copy of thisZonedDateTimewith the specified period in seconds 
subtracted. 

This operates on the instant time-line, such that subtracting one second will 
always be a duration of one second earlier. This may cause the local date-time 
to change by an amount other than one second. Note that this is a different 
approach to that used by days, months and years. 

This instance is immutable and unaffected by this method call. 


    seconds - the seconds to subtract, may be negative 

    Returns: a {@code ZonedDateTime} based on this date-time with the seconds subtracted, 
             not null 

*java.time.ZonedDateTime.minusWeeks(long)*

public |java.time.ZonedDateTime| minusWeeks(long weeks)

Returns a copy of thisZonedDateTimewith the specified period in weeks 
subtracted. 

This operates on the local time-line, subtracting 
weeks(|java.time.LocalDateTime|) to the local date-time. This is then converted 
back to aZonedDateTime, using the zone ID to obtain the offset. 

When converting back toZonedDateTime, if the local date-time is in an overlap, 
then the offset will be retained if possible, otherwise the earlier offset will 
be used. If in a gap, the local date-time will be adjusted forward by the 
length of the gap. 

This instance is immutable and unaffected by this method call. 


    weeks - the weeks to subtract, may be negative 

    Returns: a {@code ZonedDateTime} based on this date-time with the weeks subtracted, not 
             null 

*java.time.ZonedDateTime.minusYears(long)*

public |java.time.ZonedDateTime| minusYears(long years)

Returns a copy of thisZonedDateTimewith the specified period in years 
subtracted. 

This operates on the local time-line, subtracting 
years(|java.time.LocalDateTime|) to the local date-time. This is then converted 
back to aZonedDateTime, using the zone ID to obtain the offset. 

When converting back toZonedDateTime, if the local date-time is in an overlap, 
then the offset will be retained if possible, otherwise the earlier offset will 
be used. If in a gap, the local date-time will be adjusted forward by the 
length of the gap. 

This instance is immutable and unaffected by this method call. 


    years - the years to subtract, may be negative 

    Returns: a {@code ZonedDateTime} based on this date-time with the years subtracted, not 
             null 

*java.time.ZonedDateTime.now()*

public static |java.time.ZonedDateTime| now()

Obtains the current date-time from the system clock in the default time-zone. 

This will query the system clock(|java.time.Clock|) in the default time-zone to 
obtain the current date-time. The zone and offset will be set based on the 
time-zone in the clock. 

Using this method will prevent the ability to use an alternate clock for 
testing because the clock is hard-coded. 



    Returns: the current date-time using the system clock, not null 

*java.time.ZonedDateTime.now(Clock)*

public static |java.time.ZonedDateTime| now(java.time.Clock clock)

Obtains the current date-time from the specified clock. 

This will query the specified clock to obtain the current date-time. The zone 
and offset will be set based on the time-zone in the clock. 

Using this method allows the use of an alternate clock for testing. The 
alternate clock may be introduced using dependency injection(|java.time.Clock|) 
. 


    clock - the clock to use, not null 

    Returns: the current date-time, not null 

*java.time.ZonedDateTime.now(ZoneId)*

public static |java.time.ZonedDateTime| now(java.time.ZoneId zone)

Obtains the current date-time from the system clock in the specified time-zone. 

This will query the system clock(|java.time.Clock|) to obtain the current 
date-time. Specifying the time-zone avoids dependence on the default time-zone. 
The offset will be calculated from the specified time-zone. 

Using this method will prevent the ability to use an alternate clock for 
testing because the clock is hard-coded. 


    zone - the zone ID to use, not null 

    Returns: the current date-time using the system clock, not null 

*java.time.ZonedDateTime.of(int,int,int,int,int,int,int,ZoneId)*

public static |java.time.ZonedDateTime| of(
  int year,
  int month,
  int dayOfMonth,
  int hour,
  int minute,
  int second,
  int nanoOfSecond,
  java.time.ZoneId zone)

Obtains an instance ofZonedDateTimefrom a year, month, day, hour, minute, 
second, nanosecond and time-zone. 

This creates a zoned date-time matching the local date-time of the seven 
specified fields as closely as possible. Time-zone rules, such as daylight 
savings, mean that not every local date-time is valid for the specified zone, 
thus the local date-time may be adjusted. 

The local date-time is resolved to a single instant on the time-line. This is 
achieved by finding a valid offset from UTC/Greenwich for the local date-time 
as defined by the rules(|java.time.zone.ZoneRules|) of the zone ID. 

In most cases, there is only one valid offset for a local date-time. In the 
case of an overlap, when clocks are set back, there are two valid offsets. This 
method uses the earlier offset typically corresponding to "summer". 

In the case of a gap, when clocks jump forward, there is no valid offset. 
Instead, the local date-time is adjusted to be later by the length of the gap. 
For a typical one hour daylight savings change, the local date-time will be 
moved one hour later into the offset typically corresponding to "summer". 

This method exists primarily for writing test cases. Non test-code will 
typically use other methods to create an offset time.LocalDateTimehas five 
additional convenience variants of the equivalent factory method taking fewer 
arguments. They are not provided here to reduce the footprint of the API. 


    year - the year to represent, from MIN_YEAR to MAX_YEAR 
    month - the month-of-year to represent, from 1 (January) to 12 (December) 
    dayOfMonth - the day-of-month to represent, from 1 to 31 
    hour - the hour-of-day to represent, from 0 to 23 
    minute - the minute-of-hour to represent, from 0 to 59 
    second - the second-of-minute to represent, from 0 to 59 
    nanoOfSecond - the nano-of-second to represent, from 0 to 999,999,999 
    zone - the time-zone, not null 

    Returns: the offset date-time, not null 

*java.time.ZonedDateTime.of(LocalDate,LocalTime,ZoneId)*

public static |java.time.ZonedDateTime| of(
  java.time.LocalDate date,
  java.time.LocalTime time,
  java.time.ZoneId zone)

Obtains an instance ofZonedDateTimefrom a local date and time. 

This creates a zoned date-time matching the input local date and time as 
closely as possible. Time-zone rules, such as daylight savings, mean that not 
every local date-time is valid for the specified zone, thus the local date-time 
may be adjusted. 

The local date time and first combined to form a local date-time. The local 
date-time is then resolved to a single instant on the time-line. This is 
achieved by finding a valid offset from UTC/Greenwich for the local date-time 
as defined by the rules(|java.time.zone.ZoneRules|) of the zone ID. 

In most cases, there is only one valid offset for a local date-time. In the 
case of an overlap, when clocks are set back, there are two valid offsets. This 
method uses the earlier offset typically corresponding to "summer". 

In the case of a gap, when clocks jump forward, there is no valid offset. 
Instead, the local date-time is adjusted to be later by the length of the gap. 
For a typical one hour daylight savings change, the local date-time will be 
moved one hour later into the offset typically corresponding to "summer". 


    date - the local date, not null 
    time - the local time, not null 
    zone - the time-zone, not null 

    Returns: the offset date-time, not null 

*java.time.ZonedDateTime.of(LocalDateTime,ZoneId)*

public static |java.time.ZonedDateTime| of(
  java.time.LocalDateTime localDateTime,
  java.time.ZoneId zone)

Obtains an instance ofZonedDateTimefrom a local date-time. 

This creates a zoned date-time matching the input local date-time as closely as 
possible. Time-zone rules, such as daylight savings, mean that not every local 
date-time is valid for the specified zone, thus the local date-time may be 
adjusted. 

The local date-time is resolved to a single instant on the time-line. This is 
achieved by finding a valid offset from UTC/Greenwich for the local date-time 
as defined by the rules(|java.time.zone.ZoneRules|) of the zone ID. 

In most cases, there is only one valid offset for a local date-time. In the 
case of an overlap, when clocks are set back, there are two valid offsets. This 
method uses the earlier offset typically corresponding to "summer". 

In the case of a gap, when clocks jump forward, there is no valid offset. 
Instead, the local date-time is adjusted to be later by the length of the gap. 
For a typical one hour daylight savings change, the local date-time will be 
moved one hour later into the offset typically corresponding to "summer". 


    localDateTime - the local date-time, not null 
    zone - the time-zone, not null 

    Returns: the zoned date-time, not null 

*java.time.ZonedDateTime.ofInstant(Instant,ZoneId)*

public static |java.time.ZonedDateTime| ofInstant(
  java.time.Instant instant,
  java.time.ZoneId zone)

Obtains an instance ofZonedDateTimefrom anInstant. 

This creates a zoned date-time with the same instant as that specified. Calling 
(|java.time.ZonedDateTime|) will return an instant equal to the one used here. 

Converting an instant to a zoned date-time is simple as there is only one valid 
offset for each instant. 


    instant - the instant to create the date-time from, not null 
    zone - the time-zone, not null 

    Returns: the zoned date-time, not null 

*java.time.ZonedDateTime.ofInstant(LocalDateTime,ZoneOffset,ZoneId)*

public static |java.time.ZonedDateTime| ofInstant(
  java.time.LocalDateTime localDateTime,
  java.time.ZoneOffset offset,
  java.time.ZoneId zone)

Obtains an instance ofZonedDateTimefrom the instant formed by combining the 
local date-time and offset. 

This creates a zoned date-time by combining(|java.time.LocalDateTime|) 
theLocalDateTimeandZoneOffset. This combination uniquely specifies an instant 
without ambiguity. 

Converting an instant to a zoned date-time is simple as there is only one valid 
offset for each instant. If the valid offset is different to the offset 
specified, the the date-time and offset of the zoned date-time will differ from 
those specified. 

If theZoneIdto be used is aZoneOffset, this method is equivalent to 
(|java.time.ZonedDateTime|) . 


    localDateTime - the local date-time, not null 
    offset - the zone offset, not null 
    zone - the time-zone, not null 

    Returns: the zoned date-time, not null 

*java.time.ZonedDateTime.ofLocal(LocalDateTime,ZoneId,ZoneOffset)*

public static |java.time.ZonedDateTime| ofLocal(
  java.time.LocalDateTime localDateTime,
  java.time.ZoneId zone,
  java.time.ZoneOffset preferredOffset)

Obtains an instance ofZonedDateTimefrom a local date-time using the preferred 
offset if possible. 

The local date-time is resolved to a single instant on the time-line. This is 
achieved by finding a valid offset from UTC/Greenwich for the local date-time 
as defined by the rules(|java.time.zone.ZoneRules|) of the zone ID. 

In most cases, there is only one valid offset for a local date-time. In the 
case of an overlap, where clocks are set back, there are two valid offsets. If 
the preferred offset is one of the valid offsets then it is used. Otherwise the 
earlier valid offset is used, typically corresponding to "summer". 

In the case of a gap, where clocks jump forward, there is no valid offset. 
Instead, the local date-time is adjusted to be later by the length of the gap. 
For a typical one hour daylight savings change, the local date-time will be 
moved one hour later into the offset typically corresponding to "summer". 


    localDateTime - the local date-time, not null 
    zone - the time-zone, not null 
    preferredOffset - the zone offset, null if no preference 

    Returns: the zoned date-time, not null 

*java.time.ZonedDateTime.ofStrict(LocalDateTime,ZoneOffset,ZoneId)*

public static |java.time.ZonedDateTime| ofStrict(
  java.time.LocalDateTime localDateTime,
  java.time.ZoneOffset offset,
  java.time.ZoneId zone)

Obtains an instance ofZonedDateTimestrictly validating the combination of local 
date-time, offset and zone ID. 

This creates a zoned date-time ensuring that the offset is valid for the local 
date-time according to the rules of the specified zone. If the offset is 
invalid, an exception is thrown. 


    localDateTime - the local date-time, not null 
    offset - the zone offset, not null 
    zone - the time-zone, not null 

    Returns: the zoned date-time, not null 

*java.time.ZonedDateTime.parse(CharSequence)*

public static |java.time.ZonedDateTime| parse(java.lang.CharSequence text)

Obtains an instance ofZonedDateTimefrom a text string such 
as2007-12-03T10:15:30+01:00[Europe/Paris]. 

The string must represent a valid date-time and is parsed using 
(|java.time.format.DateTimeFormatter|) . 


    text - the text to parse such as "2007-12-03T10:15:30+01:00[Europe/Paris]", not null 

    Returns: the parsed zoned date-time, not null 

*java.time.ZonedDateTime.parse(CharSequence,DateTimeFormatter)*

public static |java.time.ZonedDateTime| parse(
  java.lang.CharSequence text,
  java.time.format.DateTimeFormatter formatter)

Obtains an instance ofZonedDateTimefrom a text string using a specific 
formatter. 

The text is parsed using the formatter, returning a date-time. 


    text - the text to parse, not null 
    formatter - the formatter to use, not null 

    Returns: the parsed zoned date-time, not null 

*java.time.ZonedDateTime.plus(long,TemporalUnit)*

public |java.time.ZonedDateTime| plus(
  long amountToAdd,
  java.time.temporal.TemporalUnit unit)

Returns a copy of this date-time with the specified amount added. 

This returns aZonedDateTime, based on this one, with the amount in terms of the 
unit added. If it is not possible to add the amount, because the unit is not 
supported or for some other reason, an exception is thrown. 

If the field is a (|java.time.temporal.ChronoUnit|) then the addition is 
implemented here. The zone is not part of the calculation and will be unchanged 
in the result. The calculation for date and time units differ. 

Date units operate on the local time-line. The period is first added to the 
local date-time, then converted back to a zoned date-time using the zone ID. 
The conversion uses (|java.time.ZonedDateTime|) with the offset before the 
addition. 

Time units operate on the instant time-line. The period is first added to the 
local date-time, then converted back to a zoned date-time using the zone ID. 
The conversion uses (|java.time.ZonedDateTime|) with the offset before the 
addition. 

If the field is not aChronoUnit, then the result of this method is obtained by 
invokingTemporalUnit.addTo(Temporal, long)passingthisas the argument. In this 
case, the unit determines whether and how to perform the addition. 

This instance is immutable and unaffected by this method call. 


    amountToAdd - the amount of the unit to add to the result, may be negative 
    unit - the unit of the amount to add, not null 

    Returns: a {@code ZonedDateTime} based on this date-time with the specified amount 
             added, not null 

*java.time.ZonedDateTime.plus(TemporalAmount)*

public |java.time.ZonedDateTime| plus(java.time.temporal.TemporalAmount amountToAdd)

Returns a copy of this date-time with the specified amount added. 

This returns aZonedDateTime, based on this one, with the specified amount 
added. The amount is typically (|java.time.Period|) or (|java.time.Duration|) 
but may be any other type implementing the 
(|java.time.temporal.TemporalAmount|) interface. 

The calculation is delegated to the amount object by calling 
(|java.time.temporal.TemporalAmount|) . The amount implementation is free to 
implement the addition in any way it wishes, however it typically calls back to 
(|java.time.ZonedDateTime|) . Consult the documentation of the amount 
implementation to determine if it can be successfully added. 

This instance is immutable and unaffected by this method call. 


    amountToAdd - the amount to add, not null 

    Returns: a {@code ZonedDateTime} based on this date-time with the addition made, not 
             null 

*java.time.ZonedDateTime.plusDays(long)*

public |java.time.ZonedDateTime| plusDays(long days)

Returns a copy of thisZonedDateTimewith the specified period in days added. 

This operates on the local time-line, adding days(|java.time.LocalDateTime|) to 
the local date-time. This is then converted back to aZonedDateTime, using the 
zone ID to obtain the offset. 

When converting back toZonedDateTime, if the local date-time is in an overlap, 
then the offset will be retained if possible, otherwise the earlier offset will 
be used. If in a gap, the local date-time will be adjusted forward by the 
length of the gap. 

This instance is immutable and unaffected by this method call. 


    days - the days to add, may be negative 

    Returns: a {@code ZonedDateTime} based on this date-time with the days added, not null 

*java.time.ZonedDateTime.plusHours(long)*

public |java.time.ZonedDateTime| plusHours(long hours)

Returns a copy of thisZonedDateTimewith the specified period in hours added. 

This operates on the instant time-line, such that adding one hour will always 
be a duration of one hour later. This may cause the local date-time to change 
by an amount other than one hour. Note that this is a different approach to 
that used by days, months and years, thus adding one day is not the same as 
adding 24 hours. 

For example, consider a time-zone where the spring DST cutover means that the 
local times 01:00 to 01:59 occur twice changing from offset +02:00 to +01:00. 

Adding one hour to 00:30+02:00 will result in 01:30+02:00 Adding one hour to 
01:30+02:00 will result in 01:30+01:00 Adding one hour to 01:30+01:00 will 
result in 02:30+01:00 Adding three hours to 00:30+02:00 will result in 
02:30+01:00 

This instance is immutable and unaffected by this method call. 


    hours - the hours to add, may be negative 

    Returns: a {@code ZonedDateTime} based on this date-time with the hours added, not null 

*java.time.ZonedDateTime.plusMinutes(long)*

public |java.time.ZonedDateTime| plusMinutes(long minutes)

Returns a copy of thisZonedDateTimewith the specified period in minutes added. 

This operates on the instant time-line, such that adding one minute will always 
be a duration of one minute later. This may cause the local date-time to change 
by an amount other than one minute. Note that this is a different approach to 
that used by days, months and years. 

This instance is immutable and unaffected by this method call. 


    minutes - the minutes to add, may be negative 

    Returns: a {@code ZonedDateTime} based on this date-time with the minutes added, not 
             null 

*java.time.ZonedDateTime.plusMonths(long)*

public |java.time.ZonedDateTime| plusMonths(long months)

Returns a copy of thisZonedDateTimewith the specified period in months added. 

This operates on the local time-line, adding months(|java.time.LocalDateTime|) 
to the local date-time. This is then converted back to aZonedDateTime, using 
the zone ID to obtain the offset. 

When converting back toZonedDateTime, if the local date-time is in an overlap, 
then the offset will be retained if possible, otherwise the earlier offset will 
be used. If in a gap, the local date-time will be adjusted forward by the 
length of the gap. 

This instance is immutable and unaffected by this method call. 


    months - the months to add, may be negative 

    Returns: a {@code ZonedDateTime} based on this date-time with the months added, not null 

*java.time.ZonedDateTime.plusNanos(long)*

public |java.time.ZonedDateTime| plusNanos(long nanos)

Returns a copy of thisZonedDateTimewith the specified period in nanoseconds 
added. 

This operates on the instant time-line, such that adding one nano will always 
be a duration of one nano later. This may cause the local date-time to change 
by an amount other than one nano. Note that this is a different approach to 
that used by days, months and years. 

This instance is immutable and unaffected by this method call. 


    nanos - the nanos to add, may be negative 

    Returns: a {@code ZonedDateTime} based on this date-time with the nanoseconds added, not 
             null 

*java.time.ZonedDateTime.plusSeconds(long)*

public |java.time.ZonedDateTime| plusSeconds(long seconds)

Returns a copy of thisZonedDateTimewith the specified period in seconds added. 

This operates on the instant time-line, such that adding one second will always 
be a duration of one second later. This may cause the local date-time to change 
by an amount other than one second. Note that this is a different approach to 
that used by days, months and years. 

This instance is immutable and unaffected by this method call. 


    seconds - the seconds to add, may be negative 

    Returns: a {@code ZonedDateTime} based on this date-time with the seconds added, not 
             null 

*java.time.ZonedDateTime.plusWeeks(long)*

public |java.time.ZonedDateTime| plusWeeks(long weeks)

Returns a copy of thisZonedDateTimewith the specified period in weeks added. 

This operates on the local time-line, adding weeks(|java.time.LocalDateTime|) 
to the local date-time. This is then converted back to aZonedDateTime, using 
the zone ID to obtain the offset. 

When converting back toZonedDateTime, if the local date-time is in an overlap, 
then the offset will be retained if possible, otherwise the earlier offset will 
be used. If in a gap, the local date-time will be adjusted forward by the 
length of the gap. 

This instance is immutable and unaffected by this method call. 


    weeks - the weeks to add, may be negative 

    Returns: a {@code ZonedDateTime} based on this date-time with the weeks added, not null 

*java.time.ZonedDateTime.plusYears(long)*

public |java.time.ZonedDateTime| plusYears(long years)

Returns a copy of thisZonedDateTimewith the specified period in years added. 

This operates on the local time-line, adding years(|java.time.LocalDateTime|) 
to the local date-time. This is then converted back to aZonedDateTime, using 
the zone ID to obtain the offset. 

When converting back toZonedDateTime, if the local date-time is in an overlap, 
then the offset will be retained if possible, otherwise the earlier offset will 
be used. If in a gap, the local date-time will be adjusted forward by the 
length of the gap. 

This instance is immutable and unaffected by this method call. 


    years - the years to add, may be negative 

    Returns: a {@code ZonedDateTime} based on this date-time with the years added, not null 

*java.time.ZonedDateTime.query(TemporalQuery<R>)*

public |R| query(java.time.temporal.TemporalQuery<R> query)

Queries this date-time using the specified query. 

This queries this date-time using the specified query strategy object. 
TheTemporalQueryobject defines the logic to be used to obtain the result. Read 
the documentation of the query to understand what the result of this method 
will be. 

The result of this method is obtained by invoking the 
(|java.time.temporal.TemporalQuery|) method on the specified query 
passingthisas the argument. 


    query - the query to invoke, not null 

    Returns: the query result, null may be returned (defined by the query) 

*java.time.ZonedDateTime.range(TemporalField)*

public |java.time.temporal.ValueRange| range(java.time.temporal.TemporalField field)

Gets the range of valid values for the specified field. 

The range object expresses the minimum and maximum valid values for a field. 
This date-time is used to enhance the accuracy of the returned range. If it is 
not possible to return the range, because the field is not supported or for 
some other reason, an exception is thrown. 

If the field is a (|java.time.temporal.ChronoField|) then the query is 
implemented here. The supported fields(|java.time.ZonedDateTime|) will return 
appropriate range instances. All otherChronoFieldinstances will throw 
anUnsupportedTemporalTypeException. 

If the field is not aChronoField, then the result of this method is obtained by 
invokingTemporalField.rangeRefinedBy(TemporalAccessor)passingthisas the 
argument. Whether the range can be obtained is determined by the field. 


    field - the field to query the range for, not null 

    Returns: the range of valid values for the field, not null 

*java.time.ZonedDateTime.toLocalDate()*

public |java.time.LocalDate| toLocalDate()

Gets theLocalDatepart of this date-time. 

This returns aLocalDatewith the same year, month and day as this date-time. 



    Returns: the date part of this date-time, not null 

*java.time.ZonedDateTime.toLocalDateTime()*

public |java.time.LocalDateTime| toLocalDateTime()

Gets theLocalDateTimepart of this date-time. 

This returns aLocalDateTimewith the same year, month, day and time as this 
date-time. 



    Returns: the local date-time part of this date-time, not null 

*java.time.ZonedDateTime.toLocalTime()*

public |java.time.LocalTime| toLocalTime()

Gets theLocalTimepart of this date-time. 

This returns aLocalTimewith the same hour, minute, second and nanosecond as 
this date-time. 



    Returns: the time part of this date-time, not null 

*java.time.ZonedDateTime.toOffsetDateTime()*

public |java.time.OffsetDateTime| toOffsetDateTime()

Converts this date-time to anOffsetDateTime. 

This creates an offset date-time using the local date-time and offset. The zone 
ID is ignored. 



    Returns: an offset date-time representing the same local date-time and offset, not null 

*java.time.ZonedDateTime.toString()*

public |java.lang.String| toString()

Outputs this date-time as aString, such 
as2007-12-03T10:15:30+01:00[Europe/Paris]. 

The format consists of theLocalDateTimefollowed by theZoneOffset. If 
theZoneIdis not the same as the offset, then the ID is output. The output is 
compatible with ISO-8601 if the offset and ID are the same. 



    Returns: a string representation of this date-time, not null 

*java.time.ZonedDateTime.truncatedTo(TemporalUnit)*

public |java.time.ZonedDateTime| truncatedTo(java.time.temporal.TemporalUnit unit)

Returns a copy of thisZonedDateTimewith the time truncated. 

Truncation returns a copy of the original date-time with fields smaller than 
the specified unit set to zero. For example, truncating with the 
minutes(|java.time.temporal.ChronoUnit|) unit will set the second-of-minute and 
nano-of-second field to zero. 

The unit must have a duration(|java.time.temporal.TemporalUnit|) that divides 
into the length of a standard day without remainder. This includes all supplied 
time units on (|java.time.temporal.ChronoUnit|) and 
DAYS(|java.time.temporal.ChronoUnit|) . Other units throw an exception. 

This operates on the local time-line, truncating(|java.time.LocalDateTime|) the 
underlying local date-time. This is then converted back to aZonedDateTime, 
using the zone ID to obtain the offset. 

When converting back toZonedDateTime, if the local date-time is in an overlap, 
then the offset will be retained if possible, otherwise the earlier offset will 
be used. If in a gap, the local date-time will be adjusted forward by the 
length of the gap. 

This instance is immutable and unaffected by this method call. 


    unit - the unit to truncate to, not null 

    Returns: a {@code ZonedDateTime} based on this date-time with the time truncated, not 
             null 

*java.time.ZonedDateTime.until(Temporal,TemporalUnit)*

public long until(
  java.time.temporal.Temporal endExclusive,
  java.time.temporal.TemporalUnit unit)

Calculates the amount of time until another date-time in terms of the specified 
unit. 

This calculates the amount of time between twoZonedDateTimeobjects in terms of 
a singleTemporalUnit. The start and end points arethisand the specified 
date-time. The result will be negative if the end is before the start. For 
example, the period in days between two date-times can be calculated 
usingstartDateTime.until(endDateTime, DAYS). 

TheTemporalpassed to this method is converted to aZonedDateTimeusing 
(|java.time.ZonedDateTime|) . If the time-zone differs between the two zoned 
date-times, the specified end date-time is normalized to have the same zone as 
this date-time. 

The calculation returns a whole number, representing the number of complete 
units between the two date-times. For example, the period in months between 
2012-06-15T00:00Z and 2012-08-14T23:59Z will only be one month as it is one 
minute short of two months. 

There are two equivalent ways of using this method. The first is to invoke this 
method. The second is to use (|java.time.temporal.TemporalUnit|) : 

// these two lines are equivalent amount = start.until(end, MONTHS); amount = 
MONTHS.between(start, end); 

The choice should be made based on which makes the code more readable. 

The calculation is implemented in this method for 
(|java.time.temporal.ChronoUnit|) . The 
unitsNANOS,MICROS,MILLIS,SECONDS,MINUTES,HOURSandHALF_DAYS,DAYS,WEEKS,MONTHS,YEARS,DECADES,CENTURIES,MILLENNIAandERASare
supported. OtherChronoUnitvalues will throw an exception. 

The calculation for date and time units differ. 

Date units operate on the local time-line, using the local date-time. For 
example, the period from noon on day 1 to noon the following day in days will 
always be counted as exactly one day, irrespective of whether there was a 
daylight savings change or not. 

Time units operate on the instant time-line. The calculation effectively 
converts both zoned date-times to instants and then calculates the period 
between the instants. For example, the period from noon on day 1 to noon the 
following day in hours may be 23, 24 or 25 hours (or some other amount) 
depending on whether there was a daylight savings change or not. 

If the unit is not aChronoUnit, then the result of this method is obtained by 
invokingTemporalUnit.between(Temporal, Temporal)passingthisas the first 
argument and the converted input temporal as the second argument. 

This instance is immutable and unaffected by this method call. 


    endExclusive - the end date, exclusive, which is converted to a {@code ZonedDateTime}, not 
       null 
    unit - the unit to measure the amount in, not null 

    Returns: the amount of time between this date-time and the end date-time 

*java.time.ZonedDateTime.with(TemporalAdjuster)*

public |java.time.ZonedDateTime| with(java.time.temporal.TemporalAdjuster adjuster)

Returns an adjusted copy of this date-time. 

This returns aZonedDateTime, based on this one, with the date-time adjusted. 
The adjustment takes place using the specified adjuster strategy object. Read 
the documentation of the adjuster to understand what adjustment will be made. 

A simple adjuster might simply set the one of the fields, such as the year 
field. A more complex adjuster might set the date to the last day of the month. 
A selection of common adjustments is provided in 
(|java.time.temporal.TemporalAdjuster|) . These include finding the "last day 
of the month" and "next Wednesday". Key date-time classes also implement 
theTemporalAdjusterinterface, such as (|java.time.Month|) and 
MonthDay(|java.time.MonthDay|) . The adjuster is responsible for handling 
special cases, such as the varying lengths of month and leap years. 

For example this code returns a date on the last day of July: 

import static java.time.Month.*; import static java.time.temporal.Adjusters.*; 

result = zonedDateTime.with(JULY).with(lastDayOfMonth()); 

The classes (|java.time.LocalDate|) and (|java.time.LocalTime|) 
implementTemporalAdjuster, thus this method can be used to change the date, 
time or offset: 

result = zonedDateTime.with(date); result = zonedDateTime.with(time); 

(|java.time.ZoneOffset|) also implementsTemporalAdjusterhowever using it as an 
argument typically has no effect. The offset of aZonedDateTimeis controlled 
primarily by the time-zone. As such, changing the offset does not generally 
make sense, because there is only one valid offset for the local date-time and 
zone. If the zoned date-time is in a daylight savings overlap, then the offset 
is used to switch between the two valid offsets. In all other cases, the offset 
is ignored. 

The result of this method is obtained by invoking the 
(|java.time.temporal.TemporalAdjuster|) method on the specified adjuster 
passingthisas the argument. 

This instance is immutable and unaffected by this method call. 


    adjuster - the adjuster to use, not null 

    Returns: a {@code ZonedDateTime} based on {@code this} with the adjustment made, not 
             null 

*java.time.ZonedDateTime.with(TemporalField,long)*

public |java.time.ZonedDateTime| with(
  java.time.temporal.TemporalField field,
  long newValue)

Returns a copy of this date-time with the specified field set to a new value. 

This returns aZonedDateTime, based on this one, with the value for the 
specified field changed. This can be used to change any supported field, such 
as the year, month or day-of-month. If it is not possible to set the value, 
because the field is not supported or for some other reason, an exception is 
thrown. 

In some cases, changing the specified field can cause the resulting date-time 
to become invalid, such as changing the month from 31st January to February 
would make the day-of-month invalid. In cases like this, the field is 
responsible for resolving the date. Typically it will choose the previous valid 
date, which would be the last valid day of February in this example. 

If the field is a (|java.time.temporal.ChronoField|) then the adjustment is 
implemented here. 

TheINSTANT_SECONDSfield will return a date-time with the specified instant. The 
zone and nano-of-second are unchanged. The result will have an offset derived 
from the new instant and original zone. If the new instant value is outside the 
valid range then aDateTimeExceptionwill be thrown. 

TheOFFSET_SECONDSfield will typically be ignored. The offset of 
aZonedDateTimeis controlled primarily by the time-zone. As such, changing the 
offset does not generally make sense, because there is only one valid offset 
for the local date-time and zone. If the zoned date-time is in a daylight 
savings overlap, then the offset is used to switch between the two valid 
offsets. In all other cases, the offset is ignored. If the new offset value is 
outside the valid range then aDateTimeExceptionwill be thrown. 

The other supported fields(|java.time.ZonedDateTime|) will behave as per the 
matching method on LocalDateTime(|java.time.LocalDateTime|) . The zone is not 
part of the calculation and will be unchanged. When converting back 
toZonedDateTime, if the local date-time is in an overlap, then the offset will 
be retained if possible, otherwise the earlier offset will be used. If in a 
gap, the local date-time will be adjusted forward by the length of the gap. 

All otherChronoFieldinstances will throw anUnsupportedTemporalTypeException. 

If the field is not aChronoField, then the result of this method is obtained by 
invokingTemporalField.adjustInto(Temporal, long)passingthisas the argument. In 
this case, the field determines whether and how to adjust the instant. 

This instance is immutable and unaffected by this method call. 


    field - the field to set in the result, not null 
    newValue - the new value of the field in the result 

    Returns: a {@code ZonedDateTime} based on {@code this} with the specified field set, not 
             null 

*java.time.ZonedDateTime.withDayOfMonth(int)*

public |java.time.ZonedDateTime| withDayOfMonth(int dayOfMonth)

Returns a copy of thisZonedDateTimewith the day-of-month value altered. 

This operates on the local time-line, changing the 
day-of-month(|java.time.LocalDateTime|) of the local date-time. This is then 
converted back to aZonedDateTime, using the zone ID to obtain the offset. 

When converting back toZonedDateTime, if the local date-time is in an overlap, 
then the offset will be retained if possible, otherwise the earlier offset will 
be used. If in a gap, the local date-time will be adjusted forward by the 
length of the gap. 

This instance is immutable and unaffected by this method call. 


    dayOfMonth - the day-of-month to set in the result, from 1 to 28-31 

    Returns: a {@code ZonedDateTime} based on this date-time with the requested day, not 
             null 

*java.time.ZonedDateTime.withDayOfYear(int)*

public |java.time.ZonedDateTime| withDayOfYear(int dayOfYear)

Returns a copy of thisZonedDateTimewith the day-of-year altered. 

This operates on the local time-line, changing the 
day-of-year(|java.time.LocalDateTime|) of the local date-time. This is then 
converted back to aZonedDateTime, using the zone ID to obtain the offset. 

When converting back toZonedDateTime, if the local date-time is in an overlap, 
then the offset will be retained if possible, otherwise the earlier offset will 
be used. If in a gap, the local date-time will be adjusted forward by the 
length of the gap. 

This instance is immutable and unaffected by this method call. 


    dayOfYear - the day-of-year to set in the result, from 1 to 365-366 

    Returns: a {@code ZonedDateTime} based on this date with the requested day, not null 

*java.time.ZonedDateTime.withEarlierOffsetAtOverlap()*

public |java.time.ZonedDateTime| withEarlierOffsetAtOverlap()

Returns a copy of this date-time changing the zone offset to the earlier of the 
two valid offsets at a local time-line overlap. 

This method only has any effect when the local time-line overlaps, such as at 
an autumn daylight savings cutover. In this scenario, there are two valid 
offsets for the local date-time. Calling this method will return a zoned 
date-time with the earlier of the two selected. 

If this method is called when it is not an overlap,thisis returned. 

This instance is immutable and unaffected by this method call. 



    Returns: a {@code ZonedDateTime} based on this date-time with the earlier offset, not 
             null 

*java.time.ZonedDateTime.withFixedOffsetZone()*

public |java.time.ZonedDateTime| withFixedOffsetZone()

Returns a copy of this date-time with the zone ID set to the offset. 

This returns a zoned date-time where the zone ID is the same as 
(|java.time.ZonedDateTime|) . The local date-time, offset and instant of the 
result will be the same as in this date-time. 

Setting the date-time to a fixed single offset means that any future 
calculations, such as addition or subtraction, have no complex edge cases due 
to time-zone rules. This might also be useful when sending a zoned date-time 
across a network, as most protocols, such as ISO-8601, only handle offsets, and 
not region-based zone IDs. 

This is equivalent toZonedDateTime.of(zdt.toLocalDateTime(), zdt.getOffset()). 



    Returns: a {@code ZonedDateTime} with the zone ID set to the offset, not null 

*java.time.ZonedDateTime.withHour(int)*

public |java.time.ZonedDateTime| withHour(int hour)

Returns a copy of thisZonedDateTimewith the hour-of-day value altered. 

This operates on the local time-line, changing the 
time(|java.time.LocalDateTime|) of the local date-time. This is then converted 
back to aZonedDateTime, using the zone ID to obtain the offset. 

When converting back toZonedDateTime, if the local date-time is in an overlap, 
then the offset will be retained if possible, otherwise the earlier offset will 
be used. If in a gap, the local date-time will be adjusted forward by the 
length of the gap. 

This instance is immutable and unaffected by this method call. 


    hour - the hour-of-day to set in the result, from 0 to 23 

    Returns: a {@code ZonedDateTime} based on this date-time with the requested hour, not 
             null 

*java.time.ZonedDateTime.withLaterOffsetAtOverlap()*

public |java.time.ZonedDateTime| withLaterOffsetAtOverlap()

Returns a copy of this date-time changing the zone offset to the later of the 
two valid offsets at a local time-line overlap. 

This method only has any effect when the local time-line overlaps, such as at 
an autumn daylight savings cutover. In this scenario, there are two valid 
offsets for the local date-time. Calling this method will return a zoned 
date-time with the later of the two selected. 

If this method is called when it is not an overlap,thisis returned. 

This instance is immutable and unaffected by this method call. 



    Returns: a {@code ZonedDateTime} based on this date-time with the later offset, not null 

*java.time.ZonedDateTime.withMinute(int)*

public |java.time.ZonedDateTime| withMinute(int minute)

Returns a copy of thisZonedDateTimewith the minute-of-hour value altered. 

This operates on the local time-line, changing the 
time(|java.time.LocalDateTime|) of the local date-time. This is then converted 
back to aZonedDateTime, using the zone ID to obtain the offset. 

When converting back toZonedDateTime, if the local date-time is in an overlap, 
then the offset will be retained if possible, otherwise the earlier offset will 
be used. If in a gap, the local date-time will be adjusted forward by the 
length of the gap. 

This instance is immutable and unaffected by this method call. 


    minute - the minute-of-hour to set in the result, from 0 to 59 

    Returns: a {@code ZonedDateTime} based on this date-time with the requested minute, not 
             null 

*java.time.ZonedDateTime.withMonth(int)*

public |java.time.ZonedDateTime| withMonth(int month)

Returns a copy of thisZonedDateTimewith the month-of-year value altered. 

This operates on the local time-line, changing the 
month(|java.time.LocalDateTime|) of the local date-time. This is then converted 
back to aZonedDateTime, using the zone ID to obtain the offset. 

When converting back toZonedDateTime, if the local date-time is in an overlap, 
then the offset will be retained if possible, otherwise the earlier offset will 
be used. If in a gap, the local date-time will be adjusted forward by the 
length of the gap. 

This instance is immutable and unaffected by this method call. 


    month - the month-of-year to set in the result, from 1 (January) to 12 (December) 

    Returns: a {@code ZonedDateTime} based on this date-time with the requested month, not 
             null 

*java.time.ZonedDateTime.withNano(int)*

public |java.time.ZonedDateTime| withNano(int nanoOfSecond)

Returns a copy of thisZonedDateTimewith the nano-of-second value altered. 

This operates on the local time-line, changing the 
time(|java.time.LocalDateTime|) of the local date-time. This is then converted 
back to aZonedDateTime, using the zone ID to obtain the offset. 

When converting back toZonedDateTime, if the local date-time is in an overlap, 
then the offset will be retained if possible, otherwise the earlier offset will 
be used. If in a gap, the local date-time will be adjusted forward by the 
length of the gap. 

This instance is immutable and unaffected by this method call. 


    nanoOfSecond - the nano-of-second to set in the result, from 0 to 999,999,999 

    Returns: a {@code ZonedDateTime} based on this date-time with the requested nanosecond, 
             not null 

*java.time.ZonedDateTime.withSecond(int)*

public |java.time.ZonedDateTime| withSecond(int second)

Returns a copy of thisZonedDateTimewith the second-of-minute value altered. 

This operates on the local time-line, changing the 
time(|java.time.LocalDateTime|) of the local date-time. This is then converted 
back to aZonedDateTime, using the zone ID to obtain the offset. 

When converting back toZonedDateTime, if the local date-time is in an overlap, 
then the offset will be retained if possible, otherwise the earlier offset will 
be used. If in a gap, the local date-time will be adjusted forward by the 
length of the gap. 

This instance is immutable and unaffected by this method call. 


    second - the second-of-minute to set in the result, from 0 to 59 

    Returns: a {@code ZonedDateTime} based on this date-time with the requested second, not 
             null 

*java.time.ZonedDateTime.withYear(int)*

public |java.time.ZonedDateTime| withYear(int year)

Returns a copy of thisZonedDateTimewith the year value altered. 

This operates on the local time-line, changing the 
year(|java.time.LocalDateTime|) of the local date-time. This is then converted 
back to aZonedDateTime, using the zone ID to obtain the offset. 

When converting back toZonedDateTime, if the local date-time is in an overlap, 
then the offset will be retained if possible, otherwise the earlier offset will 
be used. If in a gap, the local date-time will be adjusted forward by the 
length of the gap. 

This instance is immutable and unaffected by this method call. 


    year - the year to set in the result, from MIN_YEAR to MAX_YEAR 

    Returns: a {@code ZonedDateTime} based on this date-time with the requested year, not 
             null 

*java.time.ZonedDateTime.withZoneSameInstant(ZoneId)*

public |java.time.ZonedDateTime| withZoneSameInstant(java.time.ZoneId zone)

Returns a copy of this date-time with a different time-zone, retaining the 
instant. 

This method changes the time-zone and retains the instant. This normally 
results in a change to the local date-time. 

This method is based on retaining the same instant, thus gaps and overlaps in 
the local time-line have no effect on the result. 

To change the offset while keeping the local time, use 
(|java.time.ZonedDateTime|) . 


    zone - the time-zone to change to, not null 

    Returns: a {@code ZonedDateTime} based on this date-time with the requested zone, not 
             null 

*java.time.ZonedDateTime.withZoneSameLocal(ZoneId)*

public |java.time.ZonedDateTime| withZoneSameLocal(java.time.ZoneId zone)

Returns a copy of this date-time with a different time-zone, retaining the 
local date-time if possible. 

This method changes the time-zone and retains the local date-time. The local 
date-time is only changed if it is invalid for the new zone, determined using 
the same approach as (|java.time.ZonedDateTime|) . 

To change the zone and adjust the local date-time, use 
(|java.time.ZonedDateTime|) . 

This instance is immutable and unaffected by this method call. 


    zone - the time-zone to change to, not null 

    Returns: a {@code ZonedDateTime} based on this date-time with the requested zone, not 
             null 


